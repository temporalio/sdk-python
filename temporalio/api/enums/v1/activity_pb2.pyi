"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import sys
import typing

import google.protobuf.descriptor
import google.protobuf.internal.enum_type_wrapper

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _ActivityExecutionStatus:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ActivityExecutionStatusEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
        _ActivityExecutionStatus.ValueType
    ],
    builtins.type,
):  # noqa: F821
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ACTIVITY_EXECUTION_STATUS_UNSPECIFIED: _ActivityExecutionStatus.ValueType  # 0
    ACTIVITY_EXECUTION_STATUS_RUNNING: _ActivityExecutionStatus.ValueType  # 1
    """The activity has not reached a terminal status. See PendingActivityState for the run state
    (SCHEDULED, STARTED, or CANCEL_REQUESTED).
    """
    ACTIVITY_EXECUTION_STATUS_COMPLETED: _ActivityExecutionStatus.ValueType  # 2
    """The activity completed successfully. An activity can complete even after cancellation is
    requested if the worker calls RespondActivityTaskCompleted before acknowledging cancellation.
    """
    ACTIVITY_EXECUTION_STATUS_FAILED: _ActivityExecutionStatus.ValueType  # 3
    """The activity failed. Causes:
    - Worker returned a non-retryable failure
    - RetryPolicy.maximum_attempts exhausted
    - Attempt failed after cancellation was requested (retries blocked)
    """
    ACTIVITY_EXECUTION_STATUS_CANCELED: _ActivityExecutionStatus.ValueType  # 4
    """The activity was canceled. Reached when:
    - Cancellation requested while SCHEDULED (immediate), or
    - Cancellation requested while STARTED and worker called RespondActivityTaskCanceled.

    Workers discover cancellation requests via heartbeat responses (cancel_requested=true).
    Activities that do not heartbeat will not learn of cancellation and may complete, fail, or
    time out normally. CANCELED requires explicit worker acknowledgment or immediate cancellation
    of a SCHEDULED activity.
    """
    ACTIVITY_EXECUTION_STATUS_TERMINATED: _ActivityExecutionStatus.ValueType  # 5
    """The activity was terminated. Immediate; does not wait for worker acknowledgment."""
    ACTIVITY_EXECUTION_STATUS_TIMED_OUT: _ActivityExecutionStatus.ValueType  # 6
    """The activity timed out. See TimeoutType for the specific timeout.
    - SCHEDULE_TO_START and SCHEDULE_TO_CLOSE timeouts always result in TIMED_OUT.
    - START_TO_CLOSE and HEARTBEAT may retry if RetryPolicy permits; TIMED_OUT is
      reached when retry is blocked (RetryPolicy.maximum_attempts exhausted,
      SCHEDULE_TO_CLOSE would be exceeded, or cancellation has been requested).
    """

class ActivityExecutionStatus(
    _ActivityExecutionStatus, metaclass=_ActivityExecutionStatusEnumTypeWrapper
):
    """Status of a standalone activity.
    The status is updated once, when the activity is originally scheduled, and again when the activity reaches a terminal
    status.
    (-- api-linter: core::0216::synonyms=disabled
        aip.dev/not-precedent: Named consistently with WorkflowExecutionStatus. --)
    """

ACTIVITY_EXECUTION_STATUS_UNSPECIFIED: ActivityExecutionStatus.ValueType  # 0
ACTIVITY_EXECUTION_STATUS_RUNNING: ActivityExecutionStatus.ValueType  # 1
"""The activity has not reached a terminal status. See PendingActivityState for the run state
(SCHEDULED, STARTED, or CANCEL_REQUESTED).
"""
ACTIVITY_EXECUTION_STATUS_COMPLETED: ActivityExecutionStatus.ValueType  # 2
"""The activity completed successfully. An activity can complete even after cancellation is
requested if the worker calls RespondActivityTaskCompleted before acknowledging cancellation.
"""
ACTIVITY_EXECUTION_STATUS_FAILED: ActivityExecutionStatus.ValueType  # 3
"""The activity failed. Causes:
- Worker returned a non-retryable failure
- RetryPolicy.maximum_attempts exhausted
- Attempt failed after cancellation was requested (retries blocked)
"""
ACTIVITY_EXECUTION_STATUS_CANCELED: ActivityExecutionStatus.ValueType  # 4
"""The activity was canceled. Reached when:
- Cancellation requested while SCHEDULED (immediate), or
- Cancellation requested while STARTED and worker called RespondActivityTaskCanceled.

Workers discover cancellation requests via heartbeat responses (cancel_requested=true).
Activities that do not heartbeat will not learn of cancellation and may complete, fail, or
time out normally. CANCELED requires explicit worker acknowledgment or immediate cancellation
of a SCHEDULED activity.
"""
ACTIVITY_EXECUTION_STATUS_TERMINATED: ActivityExecutionStatus.ValueType  # 5
"""The activity was terminated. Immediate; does not wait for worker acknowledgment."""
ACTIVITY_EXECUTION_STATUS_TIMED_OUT: ActivityExecutionStatus.ValueType  # 6
"""The activity timed out. See TimeoutType for the specific timeout.
- SCHEDULE_TO_START and SCHEDULE_TO_CLOSE timeouts always result in TIMED_OUT.
- START_TO_CLOSE and HEARTBEAT may retry if RetryPolicy permits; TIMED_OUT is
  reached when retry is blocked (RetryPolicy.maximum_attempts exhausted,
  SCHEDULE_TO_CLOSE would be exceeded, or cancellation has been requested).
"""
global___ActivityExecutionStatus = ActivityExecutionStatus

class _ActivityIdReusePolicy:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ActivityIdReusePolicyEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
        _ActivityIdReusePolicy.ValueType
    ],
    builtins.type,
):  # noqa: F821
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ACTIVITY_ID_REUSE_POLICY_UNSPECIFIED: _ActivityIdReusePolicy.ValueType  # 0
    ACTIVITY_ID_REUSE_POLICY_ALLOW_DUPLICATE: _ActivityIdReusePolicy.ValueType  # 1
    """Always allow starting an activity using the same activity ID."""
    ACTIVITY_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY: (
        _ActivityIdReusePolicy.ValueType
    )  # 2
    """Allow starting an activity using the same ID only when the last activity's final state is one
    of {failed, canceled, terminated, timed out}.
    """
    ACTIVITY_ID_REUSE_POLICY_REJECT_DUPLICATE: _ActivityIdReusePolicy.ValueType  # 3
    """Do not permit re-use of the ID for this activity. Future start requests could potentially change the policy,
    allowing re-use of the ID.
    """

class ActivityIdReusePolicy(
    _ActivityIdReusePolicy, metaclass=_ActivityIdReusePolicyEnumTypeWrapper
):
    """Defines whether to allow re-using an activity ID from a previously *closed* activity.
    If the request is denied, the server returns an `ActivityExecutionAlreadyStarted` error.

    See `ActivityIdConflictPolicy` for handling ID duplication with a *running* activity.
    """

ACTIVITY_ID_REUSE_POLICY_UNSPECIFIED: ActivityIdReusePolicy.ValueType  # 0
ACTIVITY_ID_REUSE_POLICY_ALLOW_DUPLICATE: ActivityIdReusePolicy.ValueType  # 1
"""Always allow starting an activity using the same activity ID."""
ACTIVITY_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY: (
    ActivityIdReusePolicy.ValueType
)  # 2
"""Allow starting an activity using the same ID only when the last activity's final state is one
of {failed, canceled, terminated, timed out}.
"""
ACTIVITY_ID_REUSE_POLICY_REJECT_DUPLICATE: ActivityIdReusePolicy.ValueType  # 3
"""Do not permit re-use of the ID for this activity. Future start requests could potentially change the policy,
allowing re-use of the ID.
"""
global___ActivityIdReusePolicy = ActivityIdReusePolicy

class _ActivityIdConflictPolicy:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ActivityIdConflictPolicyEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
        _ActivityIdConflictPolicy.ValueType
    ],
    builtins.type,
):  # noqa: F821
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ACTIVITY_ID_CONFLICT_POLICY_UNSPECIFIED: _ActivityIdConflictPolicy.ValueType  # 0
    ACTIVITY_ID_CONFLICT_POLICY_FAIL: _ActivityIdConflictPolicy.ValueType  # 1
    """Don't start a new activity; instead return `ActivityExecutionAlreadyStarted` error."""
    ACTIVITY_ID_CONFLICT_POLICY_USE_EXISTING: _ActivityIdConflictPolicy.ValueType  # 2
    """Don't start a new activity; instead return a handle for the running activity."""

class ActivityIdConflictPolicy(
    _ActivityIdConflictPolicy, metaclass=_ActivityIdConflictPolicyEnumTypeWrapper
):
    """Defines what to do when trying to start an activity with the same ID as a *running* activity.
    Note that it is *never* valid to have two running instances of the same activity ID.

    See `ActivityIdReusePolicy` for handling activity ID duplication with a *closed* activity.
    """

ACTIVITY_ID_CONFLICT_POLICY_UNSPECIFIED: ActivityIdConflictPolicy.ValueType  # 0
ACTIVITY_ID_CONFLICT_POLICY_FAIL: ActivityIdConflictPolicy.ValueType  # 1
"""Don't start a new activity; instead return `ActivityExecutionAlreadyStarted` error."""
ACTIVITY_ID_CONFLICT_POLICY_USE_EXISTING: ActivityIdConflictPolicy.ValueType  # 2
"""Don't start a new activity; instead return a handle for the running activity."""
global___ActivityIdConflictPolicy = ActivityIdConflictPolicy
