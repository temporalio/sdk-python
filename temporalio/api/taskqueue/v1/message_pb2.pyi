"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import sys

import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.message
import google.protobuf.timestamp_pb2
import google.protobuf.wrappers_pb2

import temporalio.api.common.v1.message_pb2
import temporalio.api.deployment.v1.message_pb2
import temporalio.api.enums.v1.task_queue_pb2

if sys.version_info >= (3, 8):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class TaskQueue(google.protobuf.message.Message):
    """See https://docs.temporal.io/docs/concepts/task-queues/"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    KIND_FIELD_NUMBER: builtins.int
    NORMAL_NAME_FIELD_NUMBER: builtins.int
    name: builtins.str
    kind: temporalio.api.enums.v1.task_queue_pb2.TaskQueueKind.ValueType
    """Default: TASK_QUEUE_KIND_NORMAL."""
    normal_name: builtins.str
    """Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of
    the normal task queue that the sticky worker is running on.
    """
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        kind: temporalio.api.enums.v1.task_queue_pb2.TaskQueueKind.ValueType = ...,
        normal_name: builtins.str = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "kind", b"kind", "name", b"name", "normal_name", b"normal_name"
        ],
    ) -> None: ...

global___TaskQueue = TaskQueue

class TaskQueueMetadata(google.protobuf.message.Message):
    """Only applies to activity task queues"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MAX_TASKS_PER_SECOND_FIELD_NUMBER: builtins.int
    @property
    def max_tasks_per_second(self) -> google.protobuf.wrappers_pb2.DoubleValue:
        """Allows throttling dispatch of tasks from this queue"""
    def __init__(
        self,
        *,
        max_tasks_per_second: google.protobuf.wrappers_pb2.DoubleValue | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "max_tasks_per_second", b"max_tasks_per_second"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "max_tasks_per_second", b"max_tasks_per_second"
        ],
    ) -> None: ...

global___TaskQueueMetadata = TaskQueueMetadata

class TaskQueueVersioningInfo(google.protobuf.message.Message):
    """Experimental. Worker Deployments are experimental and might significantly change in the future."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CURRENT_DEPLOYMENT_VERSION_FIELD_NUMBER: builtins.int
    CURRENT_VERSION_FIELD_NUMBER: builtins.int
    RAMPING_DEPLOYMENT_VERSION_FIELD_NUMBER: builtins.int
    RAMPING_VERSION_FIELD_NUMBER: builtins.int
    RAMPING_VERSION_PERCENTAGE_FIELD_NUMBER: builtins.int
    UPDATE_TIME_FIELD_NUMBER: builtins.int
    @property
    def current_deployment_version(
        self,
    ) -> temporalio.api.deployment.v1.message_pb2.WorkerDeploymentVersion:
        """Specifies which Deployment Version should receive new workflow executions and tasks of
        existing unversioned or AutoUpgrade workflows.
        Nil value represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
        Note: Current Version is overridden by the Ramping Version for a portion of traffic when ramp percentage
        is non-zero (see `ramping_deployment_version` and `ramping_version_percentage`).
        """
    current_version: builtins.str
    """Deprecated. Use `current_deployment_version`."""
    @property
    def ramping_deployment_version(
        self,
    ) -> temporalio.api.deployment.v1.message_pb2.WorkerDeploymentVersion:
        """When ramp percentage is non-zero, that portion of traffic is shifted from the Current Version to the Ramping Version.
        Must always be different from `current_deployment_version` unless both are nil.
        Nil value represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
        Note that it is possible to ramp from one Version to another Version, or from unversioned
        workers to a particular Version, or from a particular Version to unversioned workers.
        """
    ramping_version: builtins.str
    """Deprecated. Use `ramping_deployment_version`."""
    ramping_version_percentage: builtins.float
    """Percentage of tasks that are routed to the Ramping Version instead of the Current Version.
    Valid range: [0, 100]. A 100% value means the Ramping Version is receiving full traffic but
    not yet "promoted" to be the Current Version, likely due to pending validations.
    A 0% value means the Ramping Version is receiving no traffic.
    """
    @property
    def update_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Last time versioning information of this Task Queue changed."""
    def __init__(
        self,
        *,
        current_deployment_version: temporalio.api.deployment.v1.message_pb2.WorkerDeploymentVersion
        | None = ...,
        current_version: builtins.str = ...,
        ramping_deployment_version: temporalio.api.deployment.v1.message_pb2.WorkerDeploymentVersion
        | None = ...,
        ramping_version: builtins.str = ...,
        ramping_version_percentage: builtins.float = ...,
        update_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "current_deployment_version",
            b"current_deployment_version",
            "ramping_deployment_version",
            b"ramping_deployment_version",
            "update_time",
            b"update_time",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "current_deployment_version",
            b"current_deployment_version",
            "current_version",
            b"current_version",
            "ramping_deployment_version",
            b"ramping_deployment_version",
            "ramping_version",
            b"ramping_version",
            "ramping_version_percentage",
            b"ramping_version_percentage",
            "update_time",
            b"update_time",
        ],
    ) -> None: ...

global___TaskQueueVersioningInfo = TaskQueueVersioningInfo

class TaskQueueVersionSelection(google.protobuf.message.Message):
    """Used for specifying versions the caller is interested in."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    BUILD_IDS_FIELD_NUMBER: builtins.int
    UNVERSIONED_FIELD_NUMBER: builtins.int
    ALL_ACTIVE_FIELD_NUMBER: builtins.int
    @property
    def build_ids(
        self,
    ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Include specific Build IDs."""
    unversioned: builtins.bool
    """Include the unversioned queue."""
    all_active: builtins.bool
    """Include all active versions. A version is considered active if, in the last few minutes,
    it has had new tasks or polls, or it has been the subject of certain task queue API calls.
    """
    def __init__(
        self,
        *,
        build_ids: collections.abc.Iterable[builtins.str] | None = ...,
        unversioned: builtins.bool = ...,
        all_active: builtins.bool = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "all_active",
            b"all_active",
            "build_ids",
            b"build_ids",
            "unversioned",
            b"unversioned",
        ],
    ) -> None: ...

global___TaskQueueVersionSelection = TaskQueueVersionSelection

class TaskQueueVersionInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class TypesInfoEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int
        @property
        def value(self) -> global___TaskQueueTypeInfo: ...
        def __init__(
            self,
            *,
            key: builtins.int = ...,
            value: global___TaskQueueTypeInfo | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing_extensions.Literal["value", b"value"]
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing_extensions.Literal["key", b"key", "value", b"value"],
        ) -> None: ...

    TYPES_INFO_FIELD_NUMBER: builtins.int
    TASK_REACHABILITY_FIELD_NUMBER: builtins.int
    @property
    def types_info(
        self,
    ) -> google.protobuf.internal.containers.MessageMap[
        builtins.int, global___TaskQueueTypeInfo
    ]:
        """Task Queue info per Task Type. Key is the numerical value of the temporalio.api.enums.v1.TaskQueueType enum."""
    task_reachability: (
        temporalio.api.enums.v1.task_queue_pb2.BuildIdTaskReachability.ValueType
    )
    """Task Reachability is eventually consistent; there may be a delay until it converges to the most
    accurate value but it is designed in a way to take the more conservative side until it converges.
    For example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.

    Note: future activities who inherit their workflow's Build ID but not its Task Queue will not be
    accounted for reachability as server cannot know if they'll happen as they do not use
    assignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows
    who inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make
    sure to query reachability for the parent/previous workflow's Task Queue as well.
    """
    def __init__(
        self,
        *,
        types_info: collections.abc.Mapping[builtins.int, global___TaskQueueTypeInfo]
        | None = ...,
        task_reachability: temporalio.api.enums.v1.task_queue_pb2.BuildIdTaskReachability.ValueType = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "task_reachability", b"task_reachability", "types_info", b"types_info"
        ],
    ) -> None: ...

global___TaskQueueVersionInfo = TaskQueueVersionInfo

class TaskQueueTypeInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    POLLERS_FIELD_NUMBER: builtins.int
    STATS_FIELD_NUMBER: builtins.int
    @property
    def pollers(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___PollerInfo
    ]:
        """Unversioned workers (with `useVersioning=false`) are reported in unversioned result even if they set a Build ID."""
    @property
    def stats(self) -> global___TaskQueueStats: ...
    def __init__(
        self,
        *,
        pollers: collections.abc.Iterable[global___PollerInfo] | None = ...,
        stats: global___TaskQueueStats | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing_extensions.Literal["stats", b"stats"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal["pollers", b"pollers", "stats", b"stats"],
    ) -> None: ...

global___TaskQueueTypeInfo = TaskQueueTypeInfo

class TaskQueueStats(google.protobuf.message.Message):
    """TaskQueueStats contains statistics about task queue backlog and activity.

    For workflow task queue type, this result is partial because tasks sent to sticky queues are not included. Read
    comments above each metric to understand the impact of sticky queue exclusion on that metric accuracy.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    APPROXIMATE_BACKLOG_COUNT_FIELD_NUMBER: builtins.int
    APPROXIMATE_BACKLOG_AGE_FIELD_NUMBER: builtins.int
    TASKS_ADD_RATE_FIELD_NUMBER: builtins.int
    TASKS_DISPATCH_RATE_FIELD_NUMBER: builtins.int
    approximate_backlog_count: builtins.int
    """The approximate number of tasks backlogged in this task queue. May count expired tasks but eventually
    converges to the right value. Can be relied upon for scaling decisions.

    Special note for workflow task queue type: this metric does not count sticky queue tasks. However, because
    those tasks only remain valid for a few seconds, the inaccuracy becomes less significant as the backlog size
    grows.
    """
    @property
    def approximate_backlog_age(self) -> google.protobuf.duration_pb2.Duration:
        """Approximate age of the oldest task in the backlog based on the creation time of the task at the head of
        the queue. Can be relied upon for scaling decisions.

        Special note for workflow task queue type: this metric does not count sticky queue tasks. However, because
        those tasks only remain valid for a few seconds, they should not affect the result when backlog is older than
        few seconds.
        """
    tasks_add_rate: builtins.float
    """The approximate tasks per second added to the task queue, averaging the last 30 seconds. These includes tasks
    whether or not they were added to/dispatched from the backlog or they were dispatched immediately without going
    to the backlog (sync-matched).

    The difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which
    backlog grows/shrinks.

    Note: the actual tasks delivered to the workers may significantly be higher than the numbers reported by
    tasks_add_rate, because:
    - Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is
      enable for activities by default in the latest SDKs.
    - Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each
      workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific
      worker instance.
    """
    tasks_dispatch_rate: builtins.float
    """The approximate tasks per second dispatched from the task queue, averaging the last 30 seconds. These includes
    tasks whether or not they were added to/dispatched from the backlog or they were dispatched immediately without
    going to the backlog (sync-matched).

    The difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which
    backlog grows/shrinks.

    Note: the actual tasks delivered to the workers may significantly be higher than the numbers reported by
    tasks_dispatch_rate, because:
    - Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is
      enable for activities by default in the latest SDKs.
    - Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each
      workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific
      worker instance.
    """
    def __init__(
        self,
        *,
        approximate_backlog_count: builtins.int = ...,
        approximate_backlog_age: google.protobuf.duration_pb2.Duration | None = ...,
        tasks_add_rate: builtins.float = ...,
        tasks_dispatch_rate: builtins.float = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "approximate_backlog_age", b"approximate_backlog_age"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "approximate_backlog_age",
            b"approximate_backlog_age",
            "approximate_backlog_count",
            b"approximate_backlog_count",
            "tasks_add_rate",
            b"tasks_add_rate",
            "tasks_dispatch_rate",
            b"tasks_dispatch_rate",
        ],
    ) -> None: ...

global___TaskQueueStats = TaskQueueStats

class TaskQueueStatus(google.protobuf.message.Message):
    """Deprecated. Use `InternalTaskQueueStatus`. This is kept until `DescribeTaskQueue` supports legacy behavior."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    BACKLOG_COUNT_HINT_FIELD_NUMBER: builtins.int
    READ_LEVEL_FIELD_NUMBER: builtins.int
    ACK_LEVEL_FIELD_NUMBER: builtins.int
    RATE_PER_SECOND_FIELD_NUMBER: builtins.int
    TASK_ID_BLOCK_FIELD_NUMBER: builtins.int
    backlog_count_hint: builtins.int
    read_level: builtins.int
    ack_level: builtins.int
    rate_per_second: builtins.float
    @property
    def task_id_block(self) -> global___TaskIdBlock: ...
    def __init__(
        self,
        *,
        backlog_count_hint: builtins.int = ...,
        read_level: builtins.int = ...,
        ack_level: builtins.int = ...,
        rate_per_second: builtins.float = ...,
        task_id_block: global___TaskIdBlock | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing_extensions.Literal["task_id_block", b"task_id_block"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "ack_level",
            b"ack_level",
            "backlog_count_hint",
            b"backlog_count_hint",
            "rate_per_second",
            b"rate_per_second",
            "read_level",
            b"read_level",
            "task_id_block",
            b"task_id_block",
        ],
    ) -> None: ...

global___TaskQueueStatus = TaskQueueStatus

class TaskIdBlock(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    START_ID_FIELD_NUMBER: builtins.int
    END_ID_FIELD_NUMBER: builtins.int
    start_id: builtins.int
    end_id: builtins.int
    def __init__(
        self,
        *,
        start_id: builtins.int = ...,
        end_id: builtins.int = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "end_id", b"end_id", "start_id", b"start_id"
        ],
    ) -> None: ...

global___TaskIdBlock = TaskIdBlock

class TaskQueuePartitionMetadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    OWNER_HOST_NAME_FIELD_NUMBER: builtins.int
    key: builtins.str
    owner_host_name: builtins.str
    def __init__(
        self,
        *,
        key: builtins.str = ...,
        owner_host_name: builtins.str = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "key", b"key", "owner_host_name", b"owner_host_name"
        ],
    ) -> None: ...

global___TaskQueuePartitionMetadata = TaskQueuePartitionMetadata

class PollerInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LAST_ACCESS_TIME_FIELD_NUMBER: builtins.int
    IDENTITY_FIELD_NUMBER: builtins.int
    RATE_PER_SECOND_FIELD_NUMBER: builtins.int
    WORKER_VERSION_CAPABILITIES_FIELD_NUMBER: builtins.int
    DEPLOYMENT_OPTIONS_FIELD_NUMBER: builtins.int
    @property
    def last_access_time(self) -> google.protobuf.timestamp_pb2.Timestamp: ...
    identity: builtins.str
    rate_per_second: builtins.float
    @property
    def worker_version_capabilities(
        self,
    ) -> temporalio.api.common.v1.message_pb2.WorkerVersionCapabilities:
        """If a worker has opted into the worker versioning feature while polling, its capabilities will
        appear here.
        Deprecated. Replaced by deployment_options.
        """
    @property
    def deployment_options(
        self,
    ) -> temporalio.api.deployment.v1.message_pb2.WorkerDeploymentOptions:
        """Worker deployment options that SDK sent to server."""
    def __init__(
        self,
        *,
        last_access_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        identity: builtins.str = ...,
        rate_per_second: builtins.float = ...,
        worker_version_capabilities: temporalio.api.common.v1.message_pb2.WorkerVersionCapabilities
        | None = ...,
        deployment_options: temporalio.api.deployment.v1.message_pb2.WorkerDeploymentOptions
        | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "deployment_options",
            b"deployment_options",
            "last_access_time",
            b"last_access_time",
            "worker_version_capabilities",
            b"worker_version_capabilities",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "deployment_options",
            b"deployment_options",
            "identity",
            b"identity",
            "last_access_time",
            b"last_access_time",
            "rate_per_second",
            b"rate_per_second",
            "worker_version_capabilities",
            b"worker_version_capabilities",
        ],
    ) -> None: ...

global___PollerInfo = PollerInfo

class StickyExecutionAttributes(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    WORKER_TASK_QUEUE_FIELD_NUMBER: builtins.int
    SCHEDULE_TO_START_TIMEOUT_FIELD_NUMBER: builtins.int
    @property
    def worker_task_queue(self) -> global___TaskQueue: ...
    @property
    def schedule_to_start_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """(-- api-linter: core::0140::prepositions=disabled
        aip.dev/not-precedent: "to" is used to indicate interval. --)
        """
    def __init__(
        self,
        *,
        worker_task_queue: global___TaskQueue | None = ...,
        schedule_to_start_timeout: google.protobuf.duration_pb2.Duration | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "schedule_to_start_timeout",
            b"schedule_to_start_timeout",
            "worker_task_queue",
            b"worker_task_queue",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "schedule_to_start_timeout",
            b"schedule_to_start_timeout",
            "worker_task_queue",
            b"worker_task_queue",
        ],
    ) -> None: ...

global___StickyExecutionAttributes = StickyExecutionAttributes

class CompatibleVersionSet(google.protobuf.message.Message):
    """Used by the worker versioning APIs, represents an unordered set of one or more versions which are
    considered to be compatible with each other. Currently the versions are always worker build IDs.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    BUILD_IDS_FIELD_NUMBER: builtins.int
    @property
    def build_ids(
        self,
    ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """All the compatible versions, unordered, except for the last element, which is considered the set "default"."""
    def __init__(
        self,
        *,
        build_ids: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing_extensions.Literal["build_ids", b"build_ids"]
    ) -> None: ...

global___CompatibleVersionSet = CompatibleVersionSet

class TaskQueueReachability(google.protobuf.message.Message):
    """Reachability of tasks for a worker on a single task queue."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TASK_QUEUE_FIELD_NUMBER: builtins.int
    REACHABILITY_FIELD_NUMBER: builtins.int
    task_queue: builtins.str
    @property
    def reachability(
        self,
    ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[
        temporalio.api.enums.v1.task_queue_pb2.TaskReachability.ValueType
    ]:
        """Task reachability for a worker in a single task queue.
        See the TaskReachability docstring for information about each enum variant.
        If reachability is empty, this worker is considered unreachable in this task queue.
        """
    def __init__(
        self,
        *,
        task_queue: builtins.str = ...,
        reachability: collections.abc.Iterable[
            temporalio.api.enums.v1.task_queue_pb2.TaskReachability.ValueType
        ]
        | None = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "reachability", b"reachability", "task_queue", b"task_queue"
        ],
    ) -> None: ...

global___TaskQueueReachability = TaskQueueReachability

class BuildIdReachability(google.protobuf.message.Message):
    """Reachability of tasks for a worker by build id, in one or more task queues."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    BUILD_ID_FIELD_NUMBER: builtins.int
    TASK_QUEUE_REACHABILITY_FIELD_NUMBER: builtins.int
    build_id: builtins.str
    """A build id or empty if unversioned."""
    @property
    def task_queue_reachability(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        global___TaskQueueReachability
    ]:
        """Reachability per task queue."""
    def __init__(
        self,
        *,
        build_id: builtins.str = ...,
        task_queue_reachability: collections.abc.Iterable[
            global___TaskQueueReachability
        ]
        | None = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "build_id",
            b"build_id",
            "task_queue_reachability",
            b"task_queue_reachability",
        ],
    ) -> None: ...

global___BuildIdReachability = BuildIdReachability

class RampByPercentage(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RAMP_PERCENTAGE_FIELD_NUMBER: builtins.int
    ramp_percentage: builtins.float
    """Acceptable range is [0,100)."""
    def __init__(
        self,
        *,
        ramp_percentage: builtins.float = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal["ramp_percentage", b"ramp_percentage"],
    ) -> None: ...

global___RampByPercentage = RampByPercentage

class BuildIdAssignmentRule(google.protobuf.message.Message):
    """Assignment rules are applied to *new* Workflow and Activity executions at
    schedule time to assign them to a Build ID.

    Assignment rules will not be used in the following cases:
       - Child Workflows or Continue-As-New Executions who inherit their
         parent/previous Workflow's assigned Build ID (by setting the
         `inherit_build_id` flag - default behavior in SDKs when the same Task Queue
         is used.)
       - An Activity that inherits the assigned Build ID of its Workflow (by
         setting the `use_workflow_build_id` flag - default behavior in SDKs
         when the same Task Queue is used.)

    In absence of (applicable) redirect rules (`CompatibleBuildIdRedirectRule`s)
    the task will be dispatched to Workers of the Build ID determined by the
    assignment rules (or inherited). Otherwise, the final Build ID will be
    determined by the redirect rules.

    Once a Workflow completes its first Workflow Task in a particular Build ID it
    stays in that Build ID regardless of changes to assignment rules. Redirect
    rules can be used to move the workflow to another compatible Build ID.

    When using Worker Versioning on a Task Queue, in the steady state,
    there should typically be a single assignment rule to send all new executions
    to the latest Build ID. Existence of at least one such "unconditional"
    rule at all times is enforces by the system, unless the `force` flag is used
    by the user when replacing/deleting these rules (for exceptional cases).

    During a deployment, one or more additional rules can be added to assign a
    subset of the tasks to a new Build ID based on a "ramp percentage".

    When there are multiple assignment rules for a Task Queue, the rules are
    evaluated in order, starting from index 0. The first applicable rule will be
    applied and the rest will be ignored.

    In the event that no assignment rule is applicable on a task (or the Task
    Queue is simply not versioned), the tasks will be dispatched to an
    unversioned Worker.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TARGET_BUILD_ID_FIELD_NUMBER: builtins.int
    PERCENTAGE_RAMP_FIELD_NUMBER: builtins.int
    target_build_id: builtins.str
    @property
    def percentage_ramp(self) -> global___RampByPercentage:
        """This ramp is useful for gradual Blue/Green deployments (and similar)
        where you want to send a certain portion of the traffic to the target
        Build ID.
        """
    def __init__(
        self,
        *,
        target_build_id: builtins.str = ...,
        percentage_ramp: global___RampByPercentage | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "percentage_ramp", b"percentage_ramp", "ramp", b"ramp"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "percentage_ramp",
            b"percentage_ramp",
            "ramp",
            b"ramp",
            "target_build_id",
            b"target_build_id",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing_extensions.Literal["ramp", b"ramp"]
    ) -> typing_extensions.Literal["percentage_ramp"] | None: ...

global___BuildIdAssignmentRule = BuildIdAssignmentRule

class CompatibleBuildIdRedirectRule(google.protobuf.message.Message):
    """These rules apply to tasks assigned to a particular Build ID
    (`source_build_id`) to redirect them to another *compatible* Build ID
    (`target_build_id`).

    It is user's responsibility to ensure that the target Build ID is compatible
    with the source Build ID (e.g. by using the Patching API).

    Most deployments are not expected to need these rules, however following
    situations can greatly benefit from redirects:
     - Need to move long-running Workflow Executions from an old Build ID to a
       newer one.
     - Need to hotfix some broken or stuck Workflow Executions.

    In steady state, redirect rules are beneficial when dealing with old
    Executions ran on now-decommissioned Build IDs:
     - To redirecting the Workflow Queries to the current (compatible) Build ID.
     - To be able to Reset an old Execution so it can run on the current
       (compatible) Build ID.

    Redirect rules can be chained.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SOURCE_BUILD_ID_FIELD_NUMBER: builtins.int
    TARGET_BUILD_ID_FIELD_NUMBER: builtins.int
    source_build_id: builtins.str
    target_build_id: builtins.str
    """Target Build ID must be compatible with the Source Build ID; that is it
    must be able to process event histories made by the Source Build ID by
    using [Patching](https://docs.temporal.io/workflows#patching) or other
    means.
    """
    def __init__(
        self,
        *,
        source_build_id: builtins.str = ...,
        target_build_id: builtins.str = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "source_build_id", b"source_build_id", "target_build_id", b"target_build_id"
        ],
    ) -> None: ...

global___CompatibleBuildIdRedirectRule = CompatibleBuildIdRedirectRule

class TimestampedBuildIdAssignmentRule(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RULE_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    @property
    def rule(self) -> global___BuildIdAssignmentRule: ...
    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp: ...
    def __init__(
        self,
        *,
        rule: global___BuildIdAssignmentRule | None = ...,
        create_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "create_time", b"create_time", "rule", b"rule"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "create_time", b"create_time", "rule", b"rule"
        ],
    ) -> None: ...

global___TimestampedBuildIdAssignmentRule = TimestampedBuildIdAssignmentRule

class TimestampedCompatibleBuildIdRedirectRule(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RULE_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    @property
    def rule(self) -> global___CompatibleBuildIdRedirectRule: ...
    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp: ...
    def __init__(
        self,
        *,
        rule: global___CompatibleBuildIdRedirectRule | None = ...,
        create_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "create_time", b"create_time", "rule", b"rule"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "create_time", b"create_time", "rule", b"rule"
        ],
    ) -> None: ...

global___TimestampedCompatibleBuildIdRedirectRule = (
    TimestampedCompatibleBuildIdRedirectRule
)

class PollerScalingDecision(google.protobuf.message.Message):
    """Attached to task responses to give hints to the SDK about how it may adjust its number of
    pollers.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    POLL_REQUEST_DELTA_SUGGESTION_FIELD_NUMBER: builtins.int
    poll_request_delta_suggestion: builtins.int
    """How many poll requests to suggest should be added or removed, if any. As of now, server only
    scales up or down by 1. However, SDKs should allow for other values (while staying within
    defined min/max).

    The SDK is free to ignore this suggestion, EX: making more polls would not make sense because
    all slots are already occupied.
    """
    def __init__(
        self,
        *,
        poll_request_delta_suggestion: builtins.int = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "poll_request_delta_suggestion", b"poll_request_delta_suggestion"
        ],
    ) -> None: ...

global___PollerScalingDecision = PollerScalingDecision

class RateLimit(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    REQUESTS_PER_SECOND_FIELD_NUMBER: builtins.int
    requests_per_second: builtins.float
    """Zero is a valid rate limit."""
    def __init__(
        self,
        *,
        requests_per_second: builtins.float = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "requests_per_second", b"requests_per_second"
        ],
    ) -> None: ...

global___RateLimit = RateLimit

class ConfigMetadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    REASON_FIELD_NUMBER: builtins.int
    UPDATE_IDENTITY_FIELD_NUMBER: builtins.int
    UPDATE_TIME_FIELD_NUMBER: builtins.int
    reason: builtins.str
    """Reason for why the config was set."""
    update_identity: builtins.str
    """Identity of the last updater.
    Set by the request's identity field.
    """
    @property
    def update_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Time of the last update."""
    def __init__(
        self,
        *,
        reason: builtins.str = ...,
        update_identity: builtins.str = ...,
        update_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing_extensions.Literal["update_time", b"update_time"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "reason",
            b"reason",
            "update_identity",
            b"update_identity",
            "update_time",
            b"update_time",
        ],
    ) -> None: ...

global___ConfigMetadata = ConfigMetadata

class RateLimitConfig(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RATE_LIMIT_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    @property
    def rate_limit(self) -> global___RateLimit: ...
    @property
    def metadata(self) -> global___ConfigMetadata: ...
    def __init__(
        self,
        *,
        rate_limit: global___RateLimit | None = ...,
        metadata: global___ConfigMetadata | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "metadata", b"metadata", "rate_limit", b"rate_limit"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "metadata", b"metadata", "rate_limit", b"rate_limit"
        ],
    ) -> None: ...

global___RateLimitConfig = RateLimitConfig

class TaskQueueConfig(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    QUEUE_RATE_LIMIT_FIELD_NUMBER: builtins.int
    FAIRNESS_KEYS_RATE_LIMIT_DEFAULT_FIELD_NUMBER: builtins.int
    @property
    def queue_rate_limit(self) -> global___RateLimitConfig:
        """Unless modified, this is the system-defined rate limit."""
    @property
    def fairness_keys_rate_limit_default(self) -> global___RateLimitConfig:
        """If set, each individual fairness key will be limited to this rate, scaled by the weight of the fairness key."""
    def __init__(
        self,
        *,
        queue_rate_limit: global___RateLimitConfig | None = ...,
        fairness_keys_rate_limit_default: global___RateLimitConfig | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "fairness_keys_rate_limit_default",
            b"fairness_keys_rate_limit_default",
            "queue_rate_limit",
            b"queue_rate_limit",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "fairness_keys_rate_limit_default",
            b"fairness_keys_rate_limit_default",
            "queue_rate_limit",
            b"queue_rate_limit",
        ],
    ) -> None: ...

global___TaskQueueConfig = TaskQueueConfig
