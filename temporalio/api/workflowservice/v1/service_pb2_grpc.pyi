"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
The MIT License

Copyright (c) 2020 Temporal Technologies Inc.  All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
"""

import abc

import grpc

import temporalio.api.workflowservice.v1.request_response_pb2

class WorkflowServiceStub:
    """WorkflowService API defines how Temporal SDKs and other clients interact with the Temporal server
    to create and interact with workflows and activities.

    Users are expected to call `StartWorkflowExecution` to create a new workflow execution.

    To drive workflows, a worker using a Temporal SDK must exist which regularly polls for workflow
    and activity tasks from the service. For each workflow task, the sdk must process the
    (incremental or complete) event history and respond back with any newly generated commands.

    For each activity task, the worker is expected to execute the user's code which implements that
    activity, responding with completion or failure.
    """

    def __init__(self, channel: grpc.Channel) -> None: ...
    RegisterNamespace: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.RegisterNamespaceRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.RegisterNamespaceResponse,
    ]
    """RegisterNamespace creates a new namespace which can be used as a container for all resources.

    A Namespace is a top level entity within Temporal, and is used as a container for resources
    like workflow executions, task queues, etc. A Namespace acts as a sandbox and provides
    isolation for all resources within the namespace. All resources belongs to exactly one
    namespace.
    """
    DescribeNamespace: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.DescribeNamespaceRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.DescribeNamespaceResponse,
    ]
    """DescribeNamespace returns the information and configuration for a registered namespace."""
    ListNamespaces: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.ListNamespacesRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.ListNamespacesResponse,
    ]
    """ListNamespaces returns the information and configuration for all namespaces."""
    UpdateNamespace: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.UpdateNamespaceRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.UpdateNamespaceResponse,
    ]
    """UpdateNamespace is used to update the information and configuration of a registered
    namespace.
    """
    DeprecateNamespace: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.DeprecateNamespaceRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.DeprecateNamespaceResponse,
    ]
    """DeprecateNamespace is used to update the state of a registered namespace to DEPRECATED.

    Once the namespace is deprecated it cannot be used to start new workflow executions. Existing
    workflow executions will continue to run on deprecated namespaces.
    Deprecated.

    (-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: Deprecated --)
    """
    StartWorkflowExecution: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.StartWorkflowExecutionRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.StartWorkflowExecutionResponse,
    ]
    """StartWorkflowExecution starts a new workflow execution.

    It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and
    also schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an
    instance already exists with same workflow id.
    """
    ExecuteMultiOperation: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.ExecuteMultiOperationRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.ExecuteMultiOperationResponse,
    ]
    """ExecuteMultiOperation executes multiple operations within a single workflow.

    Operations are started atomically, meaning if *any* operation fails to be started, none are,
    and the request fails. Upon start, the API returns only when *all* operations have a response.

    Upon failure, it returns `MultiOperationExecutionFailure` where the status code
    equals the status code of the *first* operation that failed to be started.

    NOTE: Experimental API.
    """
    GetWorkflowExecutionHistory: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.GetWorkflowExecutionHistoryRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.GetWorkflowExecutionHistoryResponse,
    ]
    """GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with
    `NotFound` if the specified workflow execution is unknown to the service.
    """
    GetWorkflowExecutionHistoryReverse: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.GetWorkflowExecutionHistoryReverseRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.GetWorkflowExecutionHistoryReverseResponse,
    ]
    """GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse 
    order (starting from last event). Fails with`NotFound` if the specified workflow execution is 
    unknown to the service.
    """
    PollWorkflowTaskQueue: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.PollWorkflowTaskQueueRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.PollWorkflowTaskQueueResponse,
    ]
    """PollWorkflowTaskQueue is called by workers to make progress on workflows.

    A WorkflowTask is dispatched to callers for active workflow executions with pending workflow
    tasks. The worker is expected to call `RespondWorkflowTaskCompleted` when it is done
    processing the task. The service will create a `WorkflowTaskStarted` event in the history for
    this task before handing it to the worker.

    (-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: We do not expose worker API to HTTP. --)
    """
    RespondWorkflowTaskCompleted: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.RespondWorkflowTaskCompletedRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.RespondWorkflowTaskCompletedResponse,
    ]
    """RespondWorkflowTaskCompleted is called by workers to successfully complete workflow tasks
    they received from `PollWorkflowTaskQueue`.

    Completing a WorkflowTask will write a `WORKFLOW_TASK_COMPLETED` event to the workflow's
    history, along with events corresponding to whatever commands the SDK generated while
    executing the task (ex timer started, activity task scheduled, etc).

    (-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: We do not expose worker API to HTTP. --)
    """
    RespondWorkflowTaskFailed: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.RespondWorkflowTaskFailedRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.RespondWorkflowTaskFailedResponse,
    ]
    """RespondWorkflowTaskFailed is called by workers to indicate the processing of a workflow task
    failed.

    This results in a `WORKFLOW_TASK_FAILED` event written to the history, and a new workflow
    task will be scheduled. This API can be used to report unhandled failures resulting from
    applying the workflow task.

    Temporal will only append first WorkflowTaskFailed event to the history of workflow execution
    for consecutive failures.

    (-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: We do not expose worker API to HTTP. --)
    """
    PollActivityTaskQueue: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.PollActivityTaskQueueRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.PollActivityTaskQueueResponse,
    ]
    """PollActivityTaskQueue is called by workers to process activity tasks from a specific task
    queue.

    The worker is expected to call one of the `RespondActivityTaskXXX` methods when it is done
    processing the task.

    An activity task is dispatched whenever a `SCHEDULE_ACTIVITY_TASK` command is produced during
    workflow execution. An in memory `ACTIVITY_TASK_STARTED` event is written to mutable state
    before the task is dispatched to the worker. The started event, and the final event
    (`ACTIVITY_TASK_COMPLETED` / `ACTIVITY_TASK_FAILED` / `ACTIVITY_TASK_TIMED_OUT`) will both be
    written permanently to Workflow execution history when Activity is finished. This is done to
    avoid writing many events in the case of a failure/retry loop.

    (-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: We do not expose worker API to HTTP. --)
    """
    RecordActivityTaskHeartbeat: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.RecordActivityTaskHeartbeatRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.RecordActivityTaskHeartbeatResponse,
    ]
    """RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.

    If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,
    then it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to
    the workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in
    such situations, in that event, the SDK should request cancellation of the activity.
    """
    RecordActivityTaskHeartbeatById: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.RecordActivityTaskHeartbeatByIdRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.RecordActivityTaskHeartbeatByIdResponse,
    ]
    """See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by
    namespace/workflow id/activity id instead of task token.

    (-- api-linter: core::0136::prepositions=disabled
        aip.dev/not-precedent: "By" is used to indicate request type. --)
    """
    RespondActivityTaskCompleted: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskCompletedRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskCompletedResponse,
    ]
    """RespondActivityTaskCompleted is called by workers when they successfully complete an activity
    task.

    This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history
    and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
    no longer valid due to activity timeout, already being completed, or never having existed.
    """
    RespondActivityTaskCompletedById: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskCompletedByIdRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskCompletedByIdResponse,
    ]
    """See `RecordActivityTaskCompleted`. This version allows clients to record completions by
    namespace/workflow id/activity id instead of task token.

    (-- api-linter: core::0136::prepositions=disabled
        aip.dev/not-precedent: "By" is used to indicate request type. --)
    """
    RespondActivityTaskFailed: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskFailedRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskFailedResponse,
    ]
    """RespondActivityTaskFailed is called by workers when processing an activity task fails.

    This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and
    a new workflow task created for the workflow. Fails with `NotFound` if the task token is no
    longer valid due to activity timeout, already being completed, or never having existed.
    """
    RespondActivityTaskFailedById: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskFailedByIdRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskFailedByIdResponse,
    ]
    """See `RecordActivityTaskFailed`. This version allows clients to record failures by
    namespace/workflow id/activity id instead of task token.

    (-- api-linter: core::0136::prepositions=disabled
        aip.dev/not-precedent: "By" is used to indicate request type. --)
    """
    RespondActivityTaskCanceled: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskCanceledRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskCanceledResponse,
    ]
    """RespondActivityTaskFailed is called by workers when processing an activity task fails.

    This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history
    and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
    no longer valid due to activity timeout, already being completed, or never having existed.
    """
    RespondActivityTaskCanceledById: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskCanceledByIdRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskCanceledByIdResponse,
    ]
    """See `RecordActivityTaskCanceled`. This version allows clients to record failures by
    namespace/workflow id/activity id instead of task token.

    (-- api-linter: core::0136::prepositions=disabled
        aip.dev/not-precedent: "By" is used to indicate request type. --)
    """
    RequestCancelWorkflowExecution: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.RequestCancelWorkflowExecutionRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.RequestCancelWorkflowExecutionResponse,
    ]
    """RequestCancelWorkflowExecution is called by workers when they want to request cancellation of
    a workflow execution.

    This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the
    workflow history and a new workflow task created for the workflow. It returns success if the requested
    workflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.
    """
    SignalWorkflowExecution: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.SignalWorkflowExecutionRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.SignalWorkflowExecutionResponse,
    ]
    """SignalWorkflowExecution is used to send a signal to a running workflow execution.

    This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow
    task being created for the execution.
    """
    SignalWithStartWorkflowExecution: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.SignalWithStartWorkflowExecutionRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.SignalWithStartWorkflowExecutionResponse,
    ]
    """SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if
    it isn't yet started.

    If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history
    and a workflow task is generated.

    If the workflow is not running or not found, then the workflow is created with
    `WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a
    workflow task is generated.

    (-- api-linter: core::0136::prepositions=disabled
        aip.dev/not-precedent: "With" is used to indicate combined operation. --)
    """
    ResetWorkflowExecution: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.ResetWorkflowExecutionRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.ResetWorkflowExecutionResponse,
    ]
    """ResetWorkflowExecution will reset an existing workflow execution to a specified
    `WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current
    execution instance.
    TODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out?
    """
    TerminateWorkflowExecution: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.TerminateWorkflowExecutionRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.TerminateWorkflowExecutionResponse,
    ]
    """TerminateWorkflowExecution terminates an existing workflow execution by recording a
    `WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the
    execution instance.
    """
    DeleteWorkflowExecution: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.DeleteWorkflowExecutionRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.DeleteWorkflowExecutionResponse,
    ]
    """DeleteWorkflowExecution asynchronously deletes a specific Workflow Execution (when
    WorkflowExecution.run_id is provided) or the latest Workflow Execution (when
    WorkflowExecution.run_id is not provided). If the Workflow Execution is Running, it will be
    terminated before deletion.

    (-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: Workflow deletion not exposed to HTTP, users should use cancel or terminate. --)
    """
    ListOpenWorkflowExecutions: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.ListOpenWorkflowExecutionsRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.ListOpenWorkflowExecutionsResponse,
    ]
    """ListOpenWorkflowExecutions is a visibility API to list the open executions in a specific namespace.

    (-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
    """
    ListClosedWorkflowExecutions: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.ListClosedWorkflowExecutionsRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.ListClosedWorkflowExecutionsResponse,
    ]
    """ListClosedWorkflowExecutions is a visibility API to list the closed executions in a specific namespace.

    (-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
    """
    ListWorkflowExecutions: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.ListWorkflowExecutionsRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.ListWorkflowExecutionsResponse,
    ]
    """ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace."""
    ListArchivedWorkflowExecutions: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.ListArchivedWorkflowExecutionsRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.ListArchivedWorkflowExecutionsResponse,
    ]
    """ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace."""
    ScanWorkflowExecutions: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.ScanWorkflowExecutionsRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.ScanWorkflowExecutionsResponse,
    ]
    """ScanWorkflowExecutions is a visibility API to list large amount of workflow executions in a specific namespace without order.

    Deprecated: Replaced with `ListWorkflowExecutions`.
    (-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
    """
    CountWorkflowExecutions: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.CountWorkflowExecutionsRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.CountWorkflowExecutionsResponse,
    ]
    """CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace."""
    GetSearchAttributes: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.GetSearchAttributesRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.GetSearchAttributesResponse,
    ]
    """GetSearchAttributes is a visibility API to get all legal keys that could be used in list APIs

    (-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: We do not expose this search attribute API to HTTP (but may expose on OperatorService). --)
    """
    RespondQueryTaskCompleted: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.RespondQueryTaskCompletedRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.RespondQueryTaskCompletedResponse,
    ]
    """RespondQueryTaskCompleted is called by workers to complete queries which were delivered on
    the `query` (not `queries`) field of a `PollWorkflowTaskQueueResponse`.

    Completing the query will unblock the corresponding client call to `QueryWorkflow` and return
    the query result a response.

    (-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: We do not expose worker API to HTTP. --)
    """
    ResetStickyTaskQueue: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.ResetStickyTaskQueueRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.ResetStickyTaskQueueResponse,
    ]
    """ResetStickyTaskQueue resets the sticky task queue related information in the mutable state of
    a given workflow. This is prudent for workers to perform if a workflow has been paged out of
    their cache.

    Things cleared are:
    1. StickyTaskQueue
    2. StickyScheduleToStartTimeout

    When possible, ShutdownWorker should be preferred over
    ResetStickyTaskQueue (particularly when a worker is shutting down or
    cycling).

    (-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: We do not expose worker API to HTTP. --)
    """
    ShutdownWorker: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.ShutdownWorkerRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.ShutdownWorkerResponse,
    ]
    """ShutdownWorker is used to indicate that the given sticky task
    queue is no longer being polled by its worker. Following the completion of
    ShutdownWorker, newly-added workflow tasks will instead be placed
    in the normal task queue, eligible for any worker to pick up.

    ShutdownWorker should be called by workers while shutting down,
    after they've shut down their pollers. If another sticky poll
    request is issued, the sticky task queue will be revived.

    As of Temporal Server v1.25.0, ShutdownWorker hasn't yet been implemented.

    (-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: We do not expose worker API to HTTP. --)
    """
    QueryWorkflow: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.QueryWorkflowRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.QueryWorkflowResponse,
    ]
    """QueryWorkflow requests a query be executed for a specified workflow execution."""
    DescribeWorkflowExecution: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.DescribeWorkflowExecutionRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.DescribeWorkflowExecutionResponse,
    ]
    """DescribeWorkflowExecution returns information about the specified workflow execution."""
    DescribeTaskQueue: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.DescribeTaskQueueRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.DescribeTaskQueueResponse,
    ]
    """DescribeTaskQueue returns the following information about the target task queue, broken down by Build ID:
      - List of pollers
      - Workflow Reachability status
      - Backlog info for Workflow and/or Activity tasks
    """
    GetClusterInfo: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.GetClusterInfoRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.GetClusterInfoResponse,
    ]
    """GetClusterInfo returns information about temporal cluster"""
    GetSystemInfo: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.GetSystemInfoRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.GetSystemInfoResponse,
    ]
    """GetSystemInfo returns information about the system."""
    ListTaskQueuePartitions: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.ListTaskQueuePartitionsRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.ListTaskQueuePartitionsResponse,
    ]
    """(-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: We do not expose this low-level API to HTTP. --)
    """
    CreateSchedule: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.CreateScheduleRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.CreateScheduleResponse,
    ]
    """Creates a new schedule."""
    DescribeSchedule: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.DescribeScheduleRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.DescribeScheduleResponse,
    ]
    """Returns the schedule description and current state of an existing schedule."""
    UpdateSchedule: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.UpdateScheduleRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.UpdateScheduleResponse,
    ]
    """Changes the configuration or state of an existing schedule."""
    PatchSchedule: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.PatchScheduleRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.PatchScheduleResponse,
    ]
    """Makes a specific change to a schedule or triggers an immediate action."""
    ListScheduleMatchingTimes: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.ListScheduleMatchingTimesRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.ListScheduleMatchingTimesResponse,
    ]
    """Lists matching times within a range."""
    DeleteSchedule: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.DeleteScheduleRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.DeleteScheduleResponse,
    ]
    """Deletes a schedule, removing it from the system."""
    ListSchedules: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.ListSchedulesRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.ListSchedulesResponse,
    ]
    """List all schedules in a namespace."""
    UpdateWorkerBuildIdCompatibility: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkerBuildIdCompatibilityRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkerBuildIdCompatibilityResponse,
    ]
    """Deprecated. Use `UpdateWorkerVersioningRules`.

    Allows users to specify sets of worker build id versions on a per task queue basis. Versions
    are ordered, and may be either compatible with some extant version, or a new incompatible
    version, forming sets of ids which are incompatible with each other, but whose contained
    members are compatible with one another.

    A single build id may be mapped to multiple task queues using this API for cases where a single process hosts
    multiple workers. 

    To query which workers can be retired, use the `GetWorkerTaskReachability` API.

    NOTE: The number of task queues mapped to a single build id is limited by the `limit.taskQueuesPerBuildId`
    (default is 20), if this limit is exceeded this API will error with a FailedPrecondition.

    (-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: We do yet expose versioning API to HTTP. --)
    """
    GetWorkerBuildIdCompatibility: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.GetWorkerBuildIdCompatibilityRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.GetWorkerBuildIdCompatibilityResponse,
    ]
    """Deprecated. Use `GetWorkerVersioningRules`.
    Fetches the worker build id versioning sets for a task queue.
    """
    UpdateWorkerVersioningRules: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkerVersioningRulesRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkerVersioningRulesResponse,
    ]
    """Use this API to manage Worker Versioning Rules for a given Task Queue. There are two types of
    rules: Build ID Assignment rules and Compatible Build ID Redirect rules.

    Assignment rules determine how to assign new executions to a Build IDs. Their primary
    use case is to specify the latest Build ID but they have powerful features for gradual rollout
    of a new Build ID.

    Once a workflow execution is assigned to a Build ID and it completes its first Workflow Task,
    the workflow stays on the assigned Build ID regardless of changes in assignment rules. This
    eliminates the need for compatibility between versions when you only care about using the new
    version for new workflows and let existing workflows finish in their own version.

    Activities, Child Workflows and Continue-as-New executions have the option to inherit the
    Build ID of their parent/previous workflow or use the latest assignment rules to independently
    select a Build ID.

    Redirect rules should only be used when you want to move workflows and activities assigned to
    one Build ID (source) to another compatible Build ID (target). You are responsible to make sure
    the target Build ID of a redirect rule is able to process event histories made by the source
    Build ID by using [Patching](https://docs.temporal.io/workflows#patching) or other means.

    WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.
    (-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: We do yet expose versioning API to HTTP. --)
    """
    GetWorkerVersioningRules: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.GetWorkerVersioningRulesRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.GetWorkerVersioningRulesResponse,
    ]
    """Fetches the Build ID assignment and redirect rules for a Task Queue.
    WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.
    """
    GetWorkerTaskReachability: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.GetWorkerTaskReachabilityRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.GetWorkerTaskReachabilityResponse,
    ]
    """Deprecated. Use `DescribeTaskQueue`.

    Fetches task reachability to determine whether a worker may be retired.
    The request may specify task queues to query for or let the server fetch all task queues mapped to the given
    build IDs.

    When requesting a large number of task queues or all task queues associated with the given build ids in a
    namespace, all task queues will be listed in the response but some of them may not contain reachability
    information due to a server enforced limit. When reaching the limit, task queues that reachability information
    could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
    another call to get the reachability for those task queues.

    Open source users can adjust this limit by setting the server's dynamic config value for
    `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
    """
    DescribeDeployment: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.DescribeDeploymentRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.DescribeDeploymentResponse,
    ]
    """Describes a worker deployment.
    Experimental. This API might significantly change or be removed in a future release.
    Deprecated. Replaced with `DescribeWorkerDeploymentVersion`.
    """
    DescribeWorkerDeploymentVersion: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.DescribeWorkerDeploymentVersionRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.DescribeWorkerDeploymentVersionResponse,
    ]
    """Describes a worker deployment version.
    Experimental. This API might significantly change or be removed in a future release.
    """
    ListDeployments: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.ListDeploymentsRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.ListDeploymentsResponse,
    ]
    """Lists worker deployments in the namespace. Optionally can filter based on deployment series
    name.
    Experimental. This API might significantly change or be removed in a future release.
    Deprecated. Replaced with `ListWorkerDeployments`.
    """
    GetDeploymentReachability: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.GetDeploymentReachabilityRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.GetDeploymentReachabilityResponse,
    ]
    """Returns the reachability level of a worker deployment to help users decide when it is time
    to decommission a deployment. Reachability level is calculated based on the deployment's
    `status` and existing workflows that depend on the given deployment for their execution.
    Calculating reachability is relatively expensive. Therefore, server might return a recently
    cached value. In such a case, the `last_update_time` will inform you about the actual
    reachability calculation time.
    Experimental. This API might significantly change or be removed in a future release.
    Deprecated. Replaced with `DrainageInfo` returned by `DescribeWorkerDeploymentVersion`.
    """
    GetCurrentDeployment: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.GetCurrentDeploymentRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.GetCurrentDeploymentResponse,
    ]
    """Returns the current deployment (and its info) for a given deployment series.
    Experimental. This API might significantly change or be removed in a future release.
    Deprecated. Replaced by `current_version` returned by `DescribeWorkerDeployment`.
    """
    SetCurrentDeployment: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.SetCurrentDeploymentRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.SetCurrentDeploymentResponse,
    ]
    """Sets a deployment as the current deployment for its deployment series. Can optionally update
    the metadata of the deployment as well.
    Experimental. This API might significantly change or be removed in a future release.
    Deprecated. Replaced by `SetWorkerDeploymentCurrentVersion`.
    """
    SetWorkerDeploymentCurrentVersion: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.SetWorkerDeploymentCurrentVersionRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.SetWorkerDeploymentCurrentVersionResponse,
    ]
    """Set/unset the Current Version of a Worker Deployment. Automatically unsets the Ramping
    Version if it is the Version being set as Current.
    Experimental. This API might significantly change or be removed in a future release.
    """
    DescribeWorkerDeployment: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.DescribeWorkerDeploymentRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.DescribeWorkerDeploymentResponse,
    ]
    """Describes a Worker Deployment.
    Experimental. This API might significantly change or be removed in a future release.
    """
    DeleteWorkerDeployment: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.DeleteWorkerDeploymentRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.DeleteWorkerDeploymentResponse,
    ]
    """Deletes records of (an old) Deployment. A deployment can only be deleted if
    it has no Version in it.
    Experimental. This API might significantly change or be removed in a future release.
    """
    DeleteWorkerDeploymentVersion: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.DeleteWorkerDeploymentVersionRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.DeleteWorkerDeploymentVersionResponse,
    ]
    """Used for manual deletion of Versions. User can delete a Version only when all the
    following conditions are met:
     - It is not the Current or Ramping Version of its Deployment.
     - It has no active pollers (none of the task queues in the Version have pollers)
     - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition
       can be skipped by passing `skip-drainage=true`.
    Experimental. This API might significantly change or be removed in a future release.
    """
    SetWorkerDeploymentRampingVersion: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.SetWorkerDeploymentRampingVersionRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.SetWorkerDeploymentRampingVersionResponse,
    ]
    """Set/unset the Ramping Version of a Worker Deployment and its ramp percentage. Can be used for
    gradual ramp to unversioned workers too.
    Experimental. This API might significantly change or be removed in a future release.
    """
    ListWorkerDeployments: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.ListWorkerDeploymentsRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.ListWorkerDeploymentsResponse,
    ]
    """Lists all Worker Deployments that are tracked in the Namespace.
    Experimental. This API might significantly change or be removed in a future release.
    """
    UpdateWorkerDeploymentVersionMetadata: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkerDeploymentVersionMetadataRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkerDeploymentVersionMetadataResponse,
    ]
    """Updates the user-given metadata attached to a Worker Deployment Version.
    Experimental. This API might significantly change or be removed in a future release.
    """
    UpdateWorkflowExecution: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkflowExecutionRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkflowExecutionResponse,
    ]
    """Invokes the specified Update function on user Workflow code."""
    PollWorkflowExecutionUpdate: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.PollWorkflowExecutionUpdateRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.PollWorkflowExecutionUpdateResponse,
    ]
    """Polls a Workflow Execution for the outcome of a Workflow Update
    previously issued through the UpdateWorkflowExecution RPC. The effective
    timeout on this call will be shorter of the the caller-supplied gRPC
    timeout and the server's configured long-poll timeout.

    (-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: We don't expose update polling API to HTTP in favor of a potential future non-blocking form. --)
    """
    StartBatchOperation: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.StartBatchOperationRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.StartBatchOperationResponse,
    ]
    """StartBatchOperation starts a new batch operation"""
    StopBatchOperation: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.StopBatchOperationRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.StopBatchOperationResponse,
    ]
    """StopBatchOperation stops a batch operation"""
    DescribeBatchOperation: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.DescribeBatchOperationRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.DescribeBatchOperationResponse,
    ]
    """DescribeBatchOperation returns the information about a batch operation"""
    ListBatchOperations: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.ListBatchOperationsRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.ListBatchOperationsResponse,
    ]
    """ListBatchOperations returns a list of batch operations"""
    PollNexusTaskQueue: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.PollNexusTaskQueueRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.PollNexusTaskQueueResponse,
    ]
    """PollNexusTaskQueue is a long poll call used by workers to receive Nexus tasks.
    (-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: We do not expose worker API to HTTP. --)
    """
    RespondNexusTaskCompleted: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.RespondNexusTaskCompletedRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.RespondNexusTaskCompletedResponse,
    ]
    """RespondNexusTaskCompleted is called by workers to respond to Nexus tasks received via PollNexusTaskQueue.
    (-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: We do not expose worker API to HTTP. --)
    """
    RespondNexusTaskFailed: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.RespondNexusTaskFailedRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.RespondNexusTaskFailedResponse,
    ]
    """RespondNexusTaskFailed is called by workers to fail Nexus tasks received via PollNexusTaskQueue.
    (-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: We do not expose worker API to HTTP. --)
    """
    UpdateActivityOptions: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.UpdateActivityOptionsRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.UpdateActivityOptionsResponse,
    ]
    """UpdateActivityOptions is called by the client to update the options of an activity by its ID or type.
    If there are multiple pending activities of the provided type - all of them will be updated.
    """
    UpdateWorkflowExecutionOptions: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkflowExecutionOptionsRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkflowExecutionOptionsResponse,
    ]
    """UpdateWorkflowExecutionOptions partially updates the WorkflowExecutionOptions of an existing workflow execution."""
    PauseActivity: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.PauseActivityRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.PauseActivityResponse,
    ]
    """PauseActivity pauses the execution of an activity specified by its ID or type.
    If there are multiple pending activities of the provided type - all of them will be paused

    Pausing an activity means:
    - If the activity is currently waiting for a retry or is running and subsequently fails,
      it will not be rescheduled until it is unpaused.
    - If the activity is already paused, calling this method will have no effect.
    - If the activity is running and finishes successfully, the activity will be completed.
    - If the activity is running and finishes with failure:
      * if there is no retry left - the activity will be completed.
      * if there are more retries left - the activity will be paused.
    For long-running activities:
    - activities in paused state will send a cancellation with "activity_paused" set to 'true' in response to 'RecordActivityTaskHeartbeat'.
    - The activity should respond to the cancellation accordingly.

    Returns a `NotFound` error if there is no pending activity with the provided ID or type
    """
    UnpauseActivity: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.UnpauseActivityRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.UnpauseActivityResponse,
    ]
    """UnpauseActivity unpauses the execution of an activity specified by its ID or type.
    If there are multiple pending activities of the provided type - all of them will be unpaused.

    If activity is not paused, this call will have no effect.
    If the activity was paused while waiting for retry, it will be scheduled immediately (* see 'jitter' flag).
    Once the activity is unpaused, all timeout timers will be regenerated.

    Flags:
    'jitter': the activity will be scheduled at a random time within the jitter duration.
    'reset_attempts': the number of attempts will be reset.
    'reset_heartbeat': the activity heartbeat timer and heartbeats will be reset.

    Returns a `NotFound` error if there is no pending activity with the provided ID or type
    """
    ResetActivity: grpc.UnaryUnaryMultiCallable[
        temporalio.api.workflowservice.v1.request_response_pb2.ResetActivityRequest,
        temporalio.api.workflowservice.v1.request_response_pb2.ResetActivityResponse,
    ]
    """ResetActivity resets the execution of an activity specified by its ID or type.
    If there are multiple pending activities of the provided type - all of them will be reset.

    Resetting an activity means:
    * number of attempts will be reset to 0.
    * activity timeouts will be reset.
    * if the activity is waiting for retry, and it is not paused or 'keep_paused' is not provided:
       it will be scheduled immediately (* see 'jitter' flag),

    Flags:

    'jitter': the activity will be scheduled at a random time within the jitter duration.
    If the activity currently paused it will be unpaused, unless 'keep_paused' flag is provided.
    'reset_heartbeats': the activity heartbeat timer and heartbeats will be reset.
    'keep_paused': if the activity is paused, it will remain paused.

    Returns a `NotFound` error if there is no pending activity with the provided ID or type.
    """

class WorkflowServiceServicer(metaclass=abc.ABCMeta):
    """WorkflowService API defines how Temporal SDKs and other clients interact with the Temporal server
    to create and interact with workflows and activities.

    Users are expected to call `StartWorkflowExecution` to create a new workflow execution.

    To drive workflows, a worker using a Temporal SDK must exist which regularly polls for workflow
    and activity tasks from the service. For each workflow task, the sdk must process the
    (incremental or complete) event history and respond back with any newly generated commands.

    For each activity task, the worker is expected to execute the user's code which implements that
    activity, responding with completion or failure.
    """

    @abc.abstractmethod
    def RegisterNamespace(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.RegisterNamespaceRequest,
        context: grpc.ServicerContext,
    ) -> (
        temporalio.api.workflowservice.v1.request_response_pb2.RegisterNamespaceResponse
    ):
        """RegisterNamespace creates a new namespace which can be used as a container for all resources.

        A Namespace is a top level entity within Temporal, and is used as a container for resources
        like workflow executions, task queues, etc. A Namespace acts as a sandbox and provides
        isolation for all resources within the namespace. All resources belongs to exactly one
        namespace.
        """
    @abc.abstractmethod
    def DescribeNamespace(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.DescribeNamespaceRequest,
        context: grpc.ServicerContext,
    ) -> (
        temporalio.api.workflowservice.v1.request_response_pb2.DescribeNamespaceResponse
    ):
        """DescribeNamespace returns the information and configuration for a registered namespace."""
    @abc.abstractmethod
    def ListNamespaces(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.ListNamespacesRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.ListNamespacesResponse:
        """ListNamespaces returns the information and configuration for all namespaces."""
    @abc.abstractmethod
    def UpdateNamespace(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.UpdateNamespaceRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.UpdateNamespaceResponse:
        """UpdateNamespace is used to update the information and configuration of a registered
        namespace.
        """
    @abc.abstractmethod
    def DeprecateNamespace(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.DeprecateNamespaceRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.DeprecateNamespaceResponse:
        """DeprecateNamespace is used to update the state of a registered namespace to DEPRECATED.

        Once the namespace is deprecated it cannot be used to start new workflow executions. Existing
        workflow executions will continue to run on deprecated namespaces.
        Deprecated.

        (-- api-linter: core::0127::http-annotation=disabled
            aip.dev/not-precedent: Deprecated --)
        """
    @abc.abstractmethod
    def StartWorkflowExecution(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.StartWorkflowExecutionRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.StartWorkflowExecutionResponse:
        """StartWorkflowExecution starts a new workflow execution.

        It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and
        also schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an
        instance already exists with same workflow id.
        """
    @abc.abstractmethod
    def ExecuteMultiOperation(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.ExecuteMultiOperationRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.ExecuteMultiOperationResponse:
        """ExecuteMultiOperation executes multiple operations within a single workflow.

        Operations are started atomically, meaning if *any* operation fails to be started, none are,
        and the request fails. Upon start, the API returns only when *all* operations have a response.

        Upon failure, it returns `MultiOperationExecutionFailure` where the status code
        equals the status code of the *first* operation that failed to be started.

        NOTE: Experimental API.
        """
    @abc.abstractmethod
    def GetWorkflowExecutionHistory(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.GetWorkflowExecutionHistoryRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.GetWorkflowExecutionHistoryResponse:
        """GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with
        `NotFound` if the specified workflow execution is unknown to the service.
        """
    @abc.abstractmethod
    def GetWorkflowExecutionHistoryReverse(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.GetWorkflowExecutionHistoryReverseRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.GetWorkflowExecutionHistoryReverseResponse:
        """GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse
        order (starting from last event). Fails with`NotFound` if the specified workflow execution is
        unknown to the service.
        """
    @abc.abstractmethod
    def PollWorkflowTaskQueue(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.PollWorkflowTaskQueueRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.PollWorkflowTaskQueueResponse:
        """PollWorkflowTaskQueue is called by workers to make progress on workflows.

        A WorkflowTask is dispatched to callers for active workflow executions with pending workflow
        tasks. The worker is expected to call `RespondWorkflowTaskCompleted` when it is done
        processing the task. The service will create a `WorkflowTaskStarted` event in the history for
        this task before handing it to the worker.

        (-- api-linter: core::0127::http-annotation=disabled
            aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        """
    @abc.abstractmethod
    def RespondWorkflowTaskCompleted(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.RespondWorkflowTaskCompletedRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.RespondWorkflowTaskCompletedResponse:
        """RespondWorkflowTaskCompleted is called by workers to successfully complete workflow tasks
        they received from `PollWorkflowTaskQueue`.

        Completing a WorkflowTask will write a `WORKFLOW_TASK_COMPLETED` event to the workflow's
        history, along with events corresponding to whatever commands the SDK generated while
        executing the task (ex timer started, activity task scheduled, etc).

        (-- api-linter: core::0127::http-annotation=disabled
            aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        """
    @abc.abstractmethod
    def RespondWorkflowTaskFailed(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.RespondWorkflowTaskFailedRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.RespondWorkflowTaskFailedResponse:
        """RespondWorkflowTaskFailed is called by workers to indicate the processing of a workflow task
        failed.

        This results in a `WORKFLOW_TASK_FAILED` event written to the history, and a new workflow
        task will be scheduled. This API can be used to report unhandled failures resulting from
        applying the workflow task.

        Temporal will only append first WorkflowTaskFailed event to the history of workflow execution
        for consecutive failures.

        (-- api-linter: core::0127::http-annotation=disabled
            aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        """
    @abc.abstractmethod
    def PollActivityTaskQueue(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.PollActivityTaskQueueRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.PollActivityTaskQueueResponse:
        """PollActivityTaskQueue is called by workers to process activity tasks from a specific task
        queue.

        The worker is expected to call one of the `RespondActivityTaskXXX` methods when it is done
        processing the task.

        An activity task is dispatched whenever a `SCHEDULE_ACTIVITY_TASK` command is produced during
        workflow execution. An in memory `ACTIVITY_TASK_STARTED` event is written to mutable state
        before the task is dispatched to the worker. The started event, and the final event
        (`ACTIVITY_TASK_COMPLETED` / `ACTIVITY_TASK_FAILED` / `ACTIVITY_TASK_TIMED_OUT`) will both be
        written permanently to Workflow execution history when Activity is finished. This is done to
        avoid writing many events in the case of a failure/retry loop.

        (-- api-linter: core::0127::http-annotation=disabled
            aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        """
    @abc.abstractmethod
    def RecordActivityTaskHeartbeat(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.RecordActivityTaskHeartbeatRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.RecordActivityTaskHeartbeatResponse:
        """RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.

        If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,
        then it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to
        the workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in
        such situations, in that event, the SDK should request cancellation of the activity.
        """
    @abc.abstractmethod
    def RecordActivityTaskHeartbeatById(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.RecordActivityTaskHeartbeatByIdRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.RecordActivityTaskHeartbeatByIdResponse:
        """See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by
        namespace/workflow id/activity id instead of task token.

        (-- api-linter: core::0136::prepositions=disabled
            aip.dev/not-precedent: "By" is used to indicate request type. --)
        """
    @abc.abstractmethod
    def RespondActivityTaskCompleted(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskCompletedRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskCompletedResponse:
        """RespondActivityTaskCompleted is called by workers when they successfully complete an activity
        task.

        This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history
        and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
        no longer valid due to activity timeout, already being completed, or never having existed.
        """
    @abc.abstractmethod
    def RespondActivityTaskCompletedById(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskCompletedByIdRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskCompletedByIdResponse:
        """See `RecordActivityTaskCompleted`. This version allows clients to record completions by
        namespace/workflow id/activity id instead of task token.

        (-- api-linter: core::0136::prepositions=disabled
            aip.dev/not-precedent: "By" is used to indicate request type. --)
        """
    @abc.abstractmethod
    def RespondActivityTaskFailed(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskFailedRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskFailedResponse:
        """RespondActivityTaskFailed is called by workers when processing an activity task fails.

        This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and
        a new workflow task created for the workflow. Fails with `NotFound` if the task token is no
        longer valid due to activity timeout, already being completed, or never having existed.
        """
    @abc.abstractmethod
    def RespondActivityTaskFailedById(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskFailedByIdRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskFailedByIdResponse:
        """See `RecordActivityTaskFailed`. This version allows clients to record failures by
        namespace/workflow id/activity id instead of task token.

        (-- api-linter: core::0136::prepositions=disabled
            aip.dev/not-precedent: "By" is used to indicate request type. --)
        """
    @abc.abstractmethod
    def RespondActivityTaskCanceled(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskCanceledRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskCanceledResponse:
        """RespondActivityTaskFailed is called by workers when processing an activity task fails.

        This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history
        and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
        no longer valid due to activity timeout, already being completed, or never having existed.
        """
    @abc.abstractmethod
    def RespondActivityTaskCanceledById(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskCanceledByIdRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.RespondActivityTaskCanceledByIdResponse:
        """See `RecordActivityTaskCanceled`. This version allows clients to record failures by
        namespace/workflow id/activity id instead of task token.

        (-- api-linter: core::0136::prepositions=disabled
            aip.dev/not-precedent: "By" is used to indicate request type. --)
        """
    @abc.abstractmethod
    def RequestCancelWorkflowExecution(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.RequestCancelWorkflowExecutionRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.RequestCancelWorkflowExecutionResponse:
        """RequestCancelWorkflowExecution is called by workers when they want to request cancellation of
        a workflow execution.

        This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the
        workflow history and a new workflow task created for the workflow. It returns success if the requested
        workflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.
        """
    @abc.abstractmethod
    def SignalWorkflowExecution(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.SignalWorkflowExecutionRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.SignalWorkflowExecutionResponse:
        """SignalWorkflowExecution is used to send a signal to a running workflow execution.

        This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow
        task being created for the execution.
        """
    @abc.abstractmethod
    def SignalWithStartWorkflowExecution(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.SignalWithStartWorkflowExecutionRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.SignalWithStartWorkflowExecutionResponse:
        """SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if
        it isn't yet started.

        If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history
        and a workflow task is generated.

        If the workflow is not running or not found, then the workflow is created with
        `WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a
        workflow task is generated.

        (-- api-linter: core::0136::prepositions=disabled
            aip.dev/not-precedent: "With" is used to indicate combined operation. --)
        """
    @abc.abstractmethod
    def ResetWorkflowExecution(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.ResetWorkflowExecutionRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.ResetWorkflowExecutionResponse:
        """ResetWorkflowExecution will reset an existing workflow execution to a specified
        `WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current
        execution instance.
        TODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out?
        """
    @abc.abstractmethod
    def TerminateWorkflowExecution(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.TerminateWorkflowExecutionRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.TerminateWorkflowExecutionResponse:
        """TerminateWorkflowExecution terminates an existing workflow execution by recording a
        `WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the
        execution instance.
        """
    @abc.abstractmethod
    def DeleteWorkflowExecution(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.DeleteWorkflowExecutionRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.DeleteWorkflowExecutionResponse:
        """DeleteWorkflowExecution asynchronously deletes a specific Workflow Execution (when
        WorkflowExecution.run_id is provided) or the latest Workflow Execution (when
        WorkflowExecution.run_id is not provided). If the Workflow Execution is Running, it will be
        terminated before deletion.

        (-- api-linter: core::0127::http-annotation=disabled
            aip.dev/not-precedent: Workflow deletion not exposed to HTTP, users should use cancel or terminate. --)
        """
    @abc.abstractmethod
    def ListOpenWorkflowExecutions(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.ListOpenWorkflowExecutionsRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.ListOpenWorkflowExecutionsResponse:
        """ListOpenWorkflowExecutions is a visibility API to list the open executions in a specific namespace.

        (-- api-linter: core::0127::http-annotation=disabled
            aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
        """
    @abc.abstractmethod
    def ListClosedWorkflowExecutions(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.ListClosedWorkflowExecutionsRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.ListClosedWorkflowExecutionsResponse:
        """ListClosedWorkflowExecutions is a visibility API to list the closed executions in a specific namespace.

        (-- api-linter: core::0127::http-annotation=disabled
            aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
        """
    @abc.abstractmethod
    def ListWorkflowExecutions(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.ListWorkflowExecutionsRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.ListWorkflowExecutionsResponse:
        """ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace."""
    @abc.abstractmethod
    def ListArchivedWorkflowExecutions(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.ListArchivedWorkflowExecutionsRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.ListArchivedWorkflowExecutionsResponse:
        """ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace."""
    @abc.abstractmethod
    def ScanWorkflowExecutions(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.ScanWorkflowExecutionsRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.ScanWorkflowExecutionsResponse:
        """ScanWorkflowExecutions is a visibility API to list large amount of workflow executions in a specific namespace without order.

        Deprecated: Replaced with `ListWorkflowExecutions`.
        (-- api-linter: core::0127::http-annotation=disabled
            aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
        """
    @abc.abstractmethod
    def CountWorkflowExecutions(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.CountWorkflowExecutionsRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.CountWorkflowExecutionsResponse:
        """CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace."""
    @abc.abstractmethod
    def GetSearchAttributes(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.GetSearchAttributesRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.GetSearchAttributesResponse:
        """GetSearchAttributes is a visibility API to get all legal keys that could be used in list APIs

        (-- api-linter: core::0127::http-annotation=disabled
            aip.dev/not-precedent: We do not expose this search attribute API to HTTP (but may expose on OperatorService). --)
        """
    @abc.abstractmethod
    def RespondQueryTaskCompleted(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.RespondQueryTaskCompletedRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.RespondQueryTaskCompletedResponse:
        """RespondQueryTaskCompleted is called by workers to complete queries which were delivered on
        the `query` (not `queries`) field of a `PollWorkflowTaskQueueResponse`.

        Completing the query will unblock the corresponding client call to `QueryWorkflow` and return
        the query result a response.

        (-- api-linter: core::0127::http-annotation=disabled
            aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        """
    @abc.abstractmethod
    def ResetStickyTaskQueue(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.ResetStickyTaskQueueRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.ResetStickyTaskQueueResponse:
        """ResetStickyTaskQueue resets the sticky task queue related information in the mutable state of
        a given workflow. This is prudent for workers to perform if a workflow has been paged out of
        their cache.

        Things cleared are:
        1. StickyTaskQueue
        2. StickyScheduleToStartTimeout

        When possible, ShutdownWorker should be preferred over
        ResetStickyTaskQueue (particularly when a worker is shutting down or
        cycling).

        (-- api-linter: core::0127::http-annotation=disabled
            aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        """
    @abc.abstractmethod
    def ShutdownWorker(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.ShutdownWorkerRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.ShutdownWorkerResponse:
        """ShutdownWorker is used to indicate that the given sticky task
        queue is no longer being polled by its worker. Following the completion of
        ShutdownWorker, newly-added workflow tasks will instead be placed
        in the normal task queue, eligible for any worker to pick up.

        ShutdownWorker should be called by workers while shutting down,
        after they've shut down their pollers. If another sticky poll
        request is issued, the sticky task queue will be revived.

        As of Temporal Server v1.25.0, ShutdownWorker hasn't yet been implemented.

        (-- api-linter: core::0127::http-annotation=disabled
            aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        """
    @abc.abstractmethod
    def QueryWorkflow(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.QueryWorkflowRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.QueryWorkflowResponse:
        """QueryWorkflow requests a query be executed for a specified workflow execution."""
    @abc.abstractmethod
    def DescribeWorkflowExecution(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.DescribeWorkflowExecutionRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.DescribeWorkflowExecutionResponse:
        """DescribeWorkflowExecution returns information about the specified workflow execution."""
    @abc.abstractmethod
    def DescribeTaskQueue(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.DescribeTaskQueueRequest,
        context: grpc.ServicerContext,
    ) -> (
        temporalio.api.workflowservice.v1.request_response_pb2.DescribeTaskQueueResponse
    ):
        """DescribeTaskQueue returns the following information about the target task queue, broken down by Build ID:
        - List of pollers
        - Workflow Reachability status
        - Backlog info for Workflow and/or Activity tasks
        """
    @abc.abstractmethod
    def GetClusterInfo(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.GetClusterInfoRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.GetClusterInfoResponse:
        """GetClusterInfo returns information about temporal cluster"""
    @abc.abstractmethod
    def GetSystemInfo(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.GetSystemInfoRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.GetSystemInfoResponse:
        """GetSystemInfo returns information about the system."""
    @abc.abstractmethod
    def ListTaskQueuePartitions(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.ListTaskQueuePartitionsRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.ListTaskQueuePartitionsResponse:
        """(-- api-linter: core::0127::http-annotation=disabled
        aip.dev/not-precedent: We do not expose this low-level API to HTTP. --)
        """
    @abc.abstractmethod
    def CreateSchedule(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.CreateScheduleRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.CreateScheduleResponse:
        """Creates a new schedule."""
    @abc.abstractmethod
    def DescribeSchedule(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.DescribeScheduleRequest,
        context: grpc.ServicerContext,
    ) -> (
        temporalio.api.workflowservice.v1.request_response_pb2.DescribeScheduleResponse
    ):
        """Returns the schedule description and current state of an existing schedule."""
    @abc.abstractmethod
    def UpdateSchedule(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.UpdateScheduleRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.UpdateScheduleResponse:
        """Changes the configuration or state of an existing schedule."""
    @abc.abstractmethod
    def PatchSchedule(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.PatchScheduleRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.PatchScheduleResponse:
        """Makes a specific change to a schedule or triggers an immediate action."""
    @abc.abstractmethod
    def ListScheduleMatchingTimes(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.ListScheduleMatchingTimesRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.ListScheduleMatchingTimesResponse:
        """Lists matching times within a range."""
    @abc.abstractmethod
    def DeleteSchedule(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.DeleteScheduleRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.DeleteScheduleResponse:
        """Deletes a schedule, removing it from the system."""
    @abc.abstractmethod
    def ListSchedules(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.ListSchedulesRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.ListSchedulesResponse:
        """List all schedules in a namespace."""
    @abc.abstractmethod
    def UpdateWorkerBuildIdCompatibility(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkerBuildIdCompatibilityRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkerBuildIdCompatibilityResponse:
        """Deprecated. Use `UpdateWorkerVersioningRules`.

        Allows users to specify sets of worker build id versions on a per task queue basis. Versions
        are ordered, and may be either compatible with some extant version, or a new incompatible
        version, forming sets of ids which are incompatible with each other, but whose contained
        members are compatible with one another.

        A single build id may be mapped to multiple task queues using this API for cases where a single process hosts
        multiple workers.

        To query which workers can be retired, use the `GetWorkerTaskReachability` API.

        NOTE: The number of task queues mapped to a single build id is limited by the `limit.taskQueuesPerBuildId`
        (default is 20), if this limit is exceeded this API will error with a FailedPrecondition.

        (-- api-linter: core::0127::http-annotation=disabled
            aip.dev/not-precedent: We do yet expose versioning API to HTTP. --)
        """
    @abc.abstractmethod
    def GetWorkerBuildIdCompatibility(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.GetWorkerBuildIdCompatibilityRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.GetWorkerBuildIdCompatibilityResponse:
        """Deprecated. Use `GetWorkerVersioningRules`.
        Fetches the worker build id versioning sets for a task queue.
        """
    @abc.abstractmethod
    def UpdateWorkerVersioningRules(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkerVersioningRulesRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkerVersioningRulesResponse:
        """Use this API to manage Worker Versioning Rules for a given Task Queue. There are two types of
        rules: Build ID Assignment rules and Compatible Build ID Redirect rules.

        Assignment rules determine how to assign new executions to a Build IDs. Their primary
        use case is to specify the latest Build ID but they have powerful features for gradual rollout
        of a new Build ID.

        Once a workflow execution is assigned to a Build ID and it completes its first Workflow Task,
        the workflow stays on the assigned Build ID regardless of changes in assignment rules. This
        eliminates the need for compatibility between versions when you only care about using the new
        version for new workflows and let existing workflows finish in their own version.

        Activities, Child Workflows and Continue-as-New executions have the option to inherit the
        Build ID of their parent/previous workflow or use the latest assignment rules to independently
        select a Build ID.

        Redirect rules should only be used when you want to move workflows and activities assigned to
        one Build ID (source) to another compatible Build ID (target). You are responsible to make sure
        the target Build ID of a redirect rule is able to process event histories made by the source
        Build ID by using [Patching](https://docs.temporal.io/workflows#patching) or other means.

        WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.
        (-- api-linter: core::0127::http-annotation=disabled
            aip.dev/not-precedent: We do yet expose versioning API to HTTP. --)
        """
    @abc.abstractmethod
    def GetWorkerVersioningRules(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.GetWorkerVersioningRulesRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.GetWorkerVersioningRulesResponse:
        """Fetches the Build ID assignment and redirect rules for a Task Queue.
        WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.
        """
    @abc.abstractmethod
    def GetWorkerTaskReachability(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.GetWorkerTaskReachabilityRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.GetWorkerTaskReachabilityResponse:
        """Deprecated. Use `DescribeTaskQueue`.

        Fetches task reachability to determine whether a worker may be retired.
        The request may specify task queues to query for or let the server fetch all task queues mapped to the given
        build IDs.

        When requesting a large number of task queues or all task queues associated with the given build ids in a
        namespace, all task queues will be listed in the response but some of them may not contain reachability
        information due to a server enforced limit. When reaching the limit, task queues that reachability information
        could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
        another call to get the reachability for those task queues.

        Open source users can adjust this limit by setting the server's dynamic config value for
        `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
        """
    @abc.abstractmethod
    def DescribeDeployment(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.DescribeDeploymentRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.DescribeDeploymentResponse:
        """Describes a worker deployment.
        Experimental. This API might significantly change or be removed in a future release.
        Deprecated. Replaced with `DescribeWorkerDeploymentVersion`.
        """
    @abc.abstractmethod
    def DescribeWorkerDeploymentVersion(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.DescribeWorkerDeploymentVersionRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.DescribeWorkerDeploymentVersionResponse:
        """Describes a worker deployment version.
        Experimental. This API might significantly change or be removed in a future release.
        """
    @abc.abstractmethod
    def ListDeployments(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.ListDeploymentsRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.ListDeploymentsResponse:
        """Lists worker deployments in the namespace. Optionally can filter based on deployment series
        name.
        Experimental. This API might significantly change or be removed in a future release.
        Deprecated. Replaced with `ListWorkerDeployments`.
        """
    @abc.abstractmethod
    def GetDeploymentReachability(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.GetDeploymentReachabilityRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.GetDeploymentReachabilityResponse:
        """Returns the reachability level of a worker deployment to help users decide when it is time
        to decommission a deployment. Reachability level is calculated based on the deployment's
        `status` and existing workflows that depend on the given deployment for their execution.
        Calculating reachability is relatively expensive. Therefore, server might return a recently
        cached value. In such a case, the `last_update_time` will inform you about the actual
        reachability calculation time.
        Experimental. This API might significantly change or be removed in a future release.
        Deprecated. Replaced with `DrainageInfo` returned by `DescribeWorkerDeploymentVersion`.
        """
    @abc.abstractmethod
    def GetCurrentDeployment(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.GetCurrentDeploymentRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.GetCurrentDeploymentResponse:
        """Returns the current deployment (and its info) for a given deployment series.
        Experimental. This API might significantly change or be removed in a future release.
        Deprecated. Replaced by `current_version` returned by `DescribeWorkerDeployment`.
        """
    @abc.abstractmethod
    def SetCurrentDeployment(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.SetCurrentDeploymentRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.SetCurrentDeploymentResponse:
        """Sets a deployment as the current deployment for its deployment series. Can optionally update
        the metadata of the deployment as well.
        Experimental. This API might significantly change or be removed in a future release.
        Deprecated. Replaced by `SetWorkerDeploymentCurrentVersion`.
        """
    @abc.abstractmethod
    def SetWorkerDeploymentCurrentVersion(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.SetWorkerDeploymentCurrentVersionRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.SetWorkerDeploymentCurrentVersionResponse:
        """Set/unset the Current Version of a Worker Deployment. Automatically unsets the Ramping
        Version if it is the Version being set as Current.
        Experimental. This API might significantly change or be removed in a future release.
        """
    @abc.abstractmethod
    def DescribeWorkerDeployment(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.DescribeWorkerDeploymentRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.DescribeWorkerDeploymentResponse:
        """Describes a Worker Deployment.
        Experimental. This API might significantly change or be removed in a future release.
        """
    @abc.abstractmethod
    def DeleteWorkerDeployment(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.DeleteWorkerDeploymentRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.DeleteWorkerDeploymentResponse:
        """Deletes records of (an old) Deployment. A deployment can only be deleted if
        it has no Version in it.
        Experimental. This API might significantly change or be removed in a future release.
        """
    @abc.abstractmethod
    def DeleteWorkerDeploymentVersion(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.DeleteWorkerDeploymentVersionRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.DeleteWorkerDeploymentVersionResponse:
        """Used for manual deletion of Versions. User can delete a Version only when all the
        following conditions are met:
         - It is not the Current or Ramping Version of its Deployment.
         - It has no active pollers (none of the task queues in the Version have pollers)
         - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition
           can be skipped by passing `skip-drainage=true`.
        Experimental. This API might significantly change or be removed in a future release.
        """
    @abc.abstractmethod
    def SetWorkerDeploymentRampingVersion(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.SetWorkerDeploymentRampingVersionRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.SetWorkerDeploymentRampingVersionResponse:
        """Set/unset the Ramping Version of a Worker Deployment and its ramp percentage. Can be used for
        gradual ramp to unversioned workers too.
        Experimental. This API might significantly change or be removed in a future release.
        """
    @abc.abstractmethod
    def ListWorkerDeployments(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.ListWorkerDeploymentsRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.ListWorkerDeploymentsResponse:
        """Lists all Worker Deployments that are tracked in the Namespace.
        Experimental. This API might significantly change or be removed in a future release.
        """
    @abc.abstractmethod
    def UpdateWorkerDeploymentVersionMetadata(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkerDeploymentVersionMetadataRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkerDeploymentVersionMetadataResponse:
        """Updates the user-given metadata attached to a Worker Deployment Version.
        Experimental. This API might significantly change or be removed in a future release.
        """
    @abc.abstractmethod
    def UpdateWorkflowExecution(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkflowExecutionRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkflowExecutionResponse:
        """Invokes the specified Update function on user Workflow code."""
    @abc.abstractmethod
    def PollWorkflowExecutionUpdate(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.PollWorkflowExecutionUpdateRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.PollWorkflowExecutionUpdateResponse:
        """Polls a Workflow Execution for the outcome of a Workflow Update
        previously issued through the UpdateWorkflowExecution RPC. The effective
        timeout on this call will be shorter of the the caller-supplied gRPC
        timeout and the server's configured long-poll timeout.

        (-- api-linter: core::0127::http-annotation=disabled
            aip.dev/not-precedent: We don't expose update polling API to HTTP in favor of a potential future non-blocking form. --)
        """
    @abc.abstractmethod
    def StartBatchOperation(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.StartBatchOperationRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.StartBatchOperationResponse:
        """StartBatchOperation starts a new batch operation"""
    @abc.abstractmethod
    def StopBatchOperation(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.StopBatchOperationRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.StopBatchOperationResponse:
        """StopBatchOperation stops a batch operation"""
    @abc.abstractmethod
    def DescribeBatchOperation(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.DescribeBatchOperationRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.DescribeBatchOperationResponse:
        """DescribeBatchOperation returns the information about a batch operation"""
    @abc.abstractmethod
    def ListBatchOperations(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.ListBatchOperationsRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.ListBatchOperationsResponse:
        """ListBatchOperations returns a list of batch operations"""
    @abc.abstractmethod
    def PollNexusTaskQueue(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.PollNexusTaskQueueRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.PollNexusTaskQueueResponse:
        """PollNexusTaskQueue is a long poll call used by workers to receive Nexus tasks.
        (-- api-linter: core::0127::http-annotation=disabled
            aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        """
    @abc.abstractmethod
    def RespondNexusTaskCompleted(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.RespondNexusTaskCompletedRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.RespondNexusTaskCompletedResponse:
        """RespondNexusTaskCompleted is called by workers to respond to Nexus tasks received via PollNexusTaskQueue.
        (-- api-linter: core::0127::http-annotation=disabled
            aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        """
    @abc.abstractmethod
    def RespondNexusTaskFailed(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.RespondNexusTaskFailedRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.RespondNexusTaskFailedResponse:
        """RespondNexusTaskFailed is called by workers to fail Nexus tasks received via PollNexusTaskQueue.
        (-- api-linter: core::0127::http-annotation=disabled
            aip.dev/not-precedent: We do not expose worker API to HTTP. --)
        """
    @abc.abstractmethod
    def UpdateActivityOptions(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.UpdateActivityOptionsRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.UpdateActivityOptionsResponse:
        """UpdateActivityOptions is called by the client to update the options of an activity by its ID or type.
        If there are multiple pending activities of the provided type - all of them will be updated.
        """
    @abc.abstractmethod
    def UpdateWorkflowExecutionOptions(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkflowExecutionOptionsRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.UpdateWorkflowExecutionOptionsResponse:
        """UpdateWorkflowExecutionOptions partially updates the WorkflowExecutionOptions of an existing workflow execution."""
    @abc.abstractmethod
    def PauseActivity(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.PauseActivityRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.PauseActivityResponse:
        """PauseActivity pauses the execution of an activity specified by its ID or type.
        If there are multiple pending activities of the provided type - all of them will be paused

        Pausing an activity means:
        - If the activity is currently waiting for a retry or is running and subsequently fails,
          it will not be rescheduled until it is unpaused.
        - If the activity is already paused, calling this method will have no effect.
        - If the activity is running and finishes successfully, the activity will be completed.
        - If the activity is running and finishes with failure:
          * if there is no retry left - the activity will be completed.
          * if there are more retries left - the activity will be paused.
        For long-running activities:
        - activities in paused state will send a cancellation with "activity_paused" set to 'true' in response to 'RecordActivityTaskHeartbeat'.
        - The activity should respond to the cancellation accordingly.

        Returns a `NotFound` error if there is no pending activity with the provided ID or type
        """
    @abc.abstractmethod
    def UnpauseActivity(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.UnpauseActivityRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.UnpauseActivityResponse:
        """UnpauseActivity unpauses the execution of an activity specified by its ID or type.
        If there are multiple pending activities of the provided type - all of them will be unpaused.

        If activity is not paused, this call will have no effect.
        If the activity was paused while waiting for retry, it will be scheduled immediately (* see 'jitter' flag).
        Once the activity is unpaused, all timeout timers will be regenerated.

        Flags:
        'jitter': the activity will be scheduled at a random time within the jitter duration.
        'reset_attempts': the number of attempts will be reset.
        'reset_heartbeat': the activity heartbeat timer and heartbeats will be reset.

        Returns a `NotFound` error if there is no pending activity with the provided ID or type
        """
    @abc.abstractmethod
    def ResetActivity(
        self,
        request: temporalio.api.workflowservice.v1.request_response_pb2.ResetActivityRequest,
        context: grpc.ServicerContext,
    ) -> temporalio.api.workflowservice.v1.request_response_pb2.ResetActivityResponse:
        """ResetActivity resets the execution of an activity specified by its ID or type.
        If there are multiple pending activities of the provided type - all of them will be reset.

        Resetting an activity means:
        * number of attempts will be reset to 0.
        * activity timeouts will be reset.
        * if the activity is waiting for retry, and it is not paused or 'keep_paused' is not provided:
           it will be scheduled immediately (* see 'jitter' flag),

        Flags:

        'jitter': the activity will be scheduled at a random time within the jitter duration.
        If the activity currently paused it will be unpaused, unless 'keep_paused' flag is provided.
        'reset_heartbeats': the activity heartbeat timer and heartbeats will be reset.
        'keep_paused': if the activity is paused, it will remain paused.

        Returns a `NotFound` error if there is no pending activity with the provided ID or type.
        """

def add_WorkflowServiceServicer_to_server(
    servicer: WorkflowServiceServicer, server: grpc.Server
) -> None: ...
