"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _WorkflowIdReusePolicy:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _WorkflowIdReusePolicyEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
        _WorkflowIdReusePolicy.ValueType
    ],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED: _WorkflowIdReusePolicy.ValueType  # 0
    WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE: _WorkflowIdReusePolicy.ValueType  # 1
    """Allow start a workflow execution using the same workflow Id, when workflow not running."""

    WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY: _WorkflowIdReusePolicy.ValueType  # 2
    """Allow start a workflow execution using the same workflow Id, when workflow not running, and the last execution close state is in
    [terminated, cancelled, timed out, failed].
    """

    WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE: _WorkflowIdReusePolicy.ValueType  # 3
    """Do not allow start a workflow execution using the same workflow Id at all."""

class WorkflowIdReusePolicy(
    _WorkflowIdReusePolicy, metaclass=_WorkflowIdReusePolicyEnumTypeWrapper
):
    pass

WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED: WorkflowIdReusePolicy.ValueType  # 0
WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE: WorkflowIdReusePolicy.ValueType  # 1
"""Allow start a workflow execution using the same workflow Id, when workflow not running."""

WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY: WorkflowIdReusePolicy.ValueType  # 2
"""Allow start a workflow execution using the same workflow Id, when workflow not running, and the last execution close state is in
[terminated, cancelled, timed out, failed].
"""

WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE: WorkflowIdReusePolicy.ValueType  # 3
"""Do not allow start a workflow execution using the same workflow Id at all."""

global___WorkflowIdReusePolicy = WorkflowIdReusePolicy

class _CancelExternalWorkflowExecutionFailedCause:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _CancelExternalWorkflowExecutionFailedCauseEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
        _CancelExternalWorkflowExecutionFailedCause.ValueType
    ],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED: _CancelExternalWorkflowExecutionFailedCause.ValueType  # 0
    CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND: _CancelExternalWorkflowExecutionFailedCause.ValueType  # 1

class CancelExternalWorkflowExecutionFailedCause(
    _CancelExternalWorkflowExecutionFailedCause,
    metaclass=_CancelExternalWorkflowExecutionFailedCauseEnumTypeWrapper,
):
    """* Possible causes of failure to cancel an external workflow"""

    pass

CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED: CancelExternalWorkflowExecutionFailedCause.ValueType  # 0
CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND: CancelExternalWorkflowExecutionFailedCause.ValueType  # 1
global___CancelExternalWorkflowExecutionFailedCause = (
    CancelExternalWorkflowExecutionFailedCause
)

class _SignalExternalWorkflowExecutionFailedCause:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SignalExternalWorkflowExecutionFailedCauseEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
        _SignalExternalWorkflowExecutionFailedCause.ValueType
    ],
    builtins.type,
):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED: _SignalExternalWorkflowExecutionFailedCause.ValueType  # 0
    SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND: _SignalExternalWorkflowExecutionFailedCause.ValueType  # 1

class SignalExternalWorkflowExecutionFailedCause(
    _SignalExternalWorkflowExecutionFailedCause,
    metaclass=_SignalExternalWorkflowExecutionFailedCauseEnumTypeWrapper,
):
    """* Possible causes of failure to signal an external workflow"""

    pass

SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED: SignalExternalWorkflowExecutionFailedCause.ValueType  # 0
SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND: SignalExternalWorkflowExecutionFailedCause.ValueType  # 1
global___SignalExternalWorkflowExecutionFailedCause = (
    SignalExternalWorkflowExecutionFailedCause
)

class Payload(google.protobuf.message.Message):
    """Many of the messages in here are exact or near duplicates of the protobufs defined by the
    Temporal API. We dupe them here to introduce better ergonomics wherever possible, and to
    decouple ourselves from upstream changes. Additionally, we have no need for wire compatibility
    between core and lang sdks, since the lang SDK chooses which version of core it wants to use.

    Used as arguments to activities, signals, queries, etc.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class MetadataEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text
        value: builtins.bytes
        def __init__(
            self,
            *,
            key: typing.Text = ...,
            value: builtins.bytes = ...,
        ) -> None: ...
        def ClearField(
            self,
            field_name: typing_extensions.Literal["key", b"key", "value", b"value"],
        ) -> None: ...
    METADATA_FIELD_NUMBER: builtins.int
    DATA_FIELD_NUMBER: builtins.int
    @property
    def metadata(
        self,
    ) -> google.protobuf.internal.containers.ScalarMap[typing.Text, builtins.bytes]: ...
    data: builtins.bytes
    def __init__(
        self,
        *,
        metadata: typing.Optional[typing.Mapping[typing.Text, builtins.bytes]] = ...,
        data: builtins.bytes = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal["data", b"data", "metadata", b"metadata"],
    ) -> None: ...

global___Payload = Payload

class WorkflowExecution(google.protobuf.message.Message):
    """Identifying information about a particular workflow execution. Namespace is expected to be
    assumed or included in whatever message is wrapping this one.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    WORKFLOW_ID_FIELD_NUMBER: builtins.int
    RUN_ID_FIELD_NUMBER: builtins.int
    workflow_id: typing.Text
    """Can never be empty"""

    run_id: typing.Text
    """May be empty if the most recent run of the workflow with the given ID is being targeted"""
    def __init__(
        self,
        *,
        workflow_id: typing.Text = ...,
        run_id: typing.Text = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "run_id", b"run_id", "workflow_id", b"workflow_id"
        ],
    ) -> None: ...

global___WorkflowExecution = WorkflowExecution

class NamespacedWorkflowExecution(google.protobuf.message.Message):
    """Identifying information about a particular workflow execution, including namespace"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAMESPACE_FIELD_NUMBER: builtins.int
    WORKFLOW_ID_FIELD_NUMBER: builtins.int
    RUN_ID_FIELD_NUMBER: builtins.int
    namespace: typing.Text
    """Namespace the workflow run is located in"""

    workflow_id: typing.Text
    """Can never be empty"""

    run_id: typing.Text
    """May be empty if the most recent run of the workflow with the given ID is being targeted"""
    def __init__(
        self,
        *,
        namespace: typing.Text = ...,
        workflow_id: typing.Text = ...,
        run_id: typing.Text = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "namespace",
            b"namespace",
            "run_id",
            b"run_id",
            "workflow_id",
            b"workflow_id",
        ],
    ) -> None: ...

global___NamespacedWorkflowExecution = NamespacedWorkflowExecution

class RetryPolicy(google.protobuf.message.Message):
    """Defines how an activity or workflow should be retried in the event of failure, timeout, etc.
    Defaults may differ depending on what this is being used for. See containing messages.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    INITIAL_INTERVAL_FIELD_NUMBER: builtins.int
    BACKOFF_COEFFICIENT_FIELD_NUMBER: builtins.int
    MAXIMUM_INTERVAL_FIELD_NUMBER: builtins.int
    MAXIMUM_ATTEMPTS_FIELD_NUMBER: builtins.int
    NON_RETRYABLE_ERROR_TYPES_FIELD_NUMBER: builtins.int
    @property
    def initial_interval(self) -> google.protobuf.duration_pb2.Duration:
        """Interval of the first retry. If backoff_coefficient is 1.0 then it is used for all
        retries. If this is not specified, there will be *no retrying*. Lang SDKs should require
        this to be set.
        """
        pass
    backoff_coefficient: builtins.float
    """Coefficient used to calculate the next retry interval. The next retry interval is previous
    interval multiplied by the coefficient. Must be 1 or larger.
    """
    @property
    def maximum_interval(self) -> google.protobuf.duration_pb2.Duration:
        """Maximum interval between retries. Exponential backoff leads to interval increase. This value
        caps that interval.
        """
        pass
    maximum_attempts: builtins.int
    """Maximum number of attempts. When exceeded, retrying will stop. 1 disables retries. 0 means
    unlimited retries (until the activity or workflow's total timeout is reached).
    """
    @property
    def non_retryable_error_types(
        self,
    ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """If a stringified error type matches something in this list, retries will cease."""
        pass
    def __init__(
        self,
        *,
        initial_interval: typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        backoff_coefficient: builtins.float = ...,
        maximum_interval: typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        maximum_attempts: builtins.int = ...,
        non_retryable_error_types: typing.Optional[typing.Iterable[typing.Text]] = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "initial_interval",
            b"initial_interval",
            "maximum_interval",
            b"maximum_interval",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "backoff_coefficient",
            b"backoff_coefficient",
            "initial_interval",
            b"initial_interval",
            "maximum_attempts",
            b"maximum_attempts",
            "maximum_interval",
            b"maximum_interval",
            "non_retryable_error_types",
            b"non_retryable_error_types",
        ],
    ) -> None: ...

global___RetryPolicy = RetryPolicy
