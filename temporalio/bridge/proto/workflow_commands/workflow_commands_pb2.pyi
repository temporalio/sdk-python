"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file

Definitions for commands from a workflow in lang SDK to core. While a workflow processes a batch
of activation jobs, it accumulates these commands to be sent back to core to conclude that
activation.
"""

import builtins
import collections.abc
import sys
import typing

import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.empty_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2

import temporalio.api.common.v1.message_pb2
import temporalio.api.enums.v1.workflow_pb2
import temporalio.api.failure.v1.message_pb2
import temporalio.api.sdk.v1.user_metadata_pb2
import temporalio.bridge.proto.child_workflow.child_workflow_pb2
import temporalio.bridge.proto.common.common_pb2
import temporalio.bridge.proto.nexus.nexus_pb2

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _ActivityCancellationType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ActivityCancellationTypeEnumTypeWrapper(
    google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[
        _ActivityCancellationType.ValueType
    ],
    builtins.type,
):  # noqa: F821
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    TRY_CANCEL: _ActivityCancellationType.ValueType  # 0
    """Initiate a cancellation request and immediately report cancellation to the workflow."""
    WAIT_CANCELLATION_COMPLETED: _ActivityCancellationType.ValueType  # 1
    """Wait for activity cancellation completion. Note that activity must heartbeat to receive a
    cancellation notification. This can block the cancellation for a long time if activity
    doesn't heartbeat or chooses to ignore the cancellation request.
    """
    ABANDON: _ActivityCancellationType.ValueType  # 2
    """Do not request cancellation of the activity and immediately report cancellation to the
    workflow
    """

class ActivityCancellationType(
    _ActivityCancellationType, metaclass=_ActivityCancellationTypeEnumTypeWrapper
): ...

TRY_CANCEL: ActivityCancellationType.ValueType  # 0
"""Initiate a cancellation request and immediately report cancellation to the workflow."""
WAIT_CANCELLATION_COMPLETED: ActivityCancellationType.ValueType  # 1
"""Wait for activity cancellation completion. Note that activity must heartbeat to receive a
cancellation notification. This can block the cancellation for a long time if activity
doesn't heartbeat or chooses to ignore the cancellation request.
"""
ABANDON: ActivityCancellationType.ValueType  # 2
"""Do not request cancellation of the activity and immediately report cancellation to the
workflow
"""
global___ActivityCancellationType = ActivityCancellationType

class WorkflowCommand(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    USER_METADATA_FIELD_NUMBER: builtins.int
    START_TIMER_FIELD_NUMBER: builtins.int
    SCHEDULE_ACTIVITY_FIELD_NUMBER: builtins.int
    RESPOND_TO_QUERY_FIELD_NUMBER: builtins.int
    REQUEST_CANCEL_ACTIVITY_FIELD_NUMBER: builtins.int
    CANCEL_TIMER_FIELD_NUMBER: builtins.int
    COMPLETE_WORKFLOW_EXECUTION_FIELD_NUMBER: builtins.int
    FAIL_WORKFLOW_EXECUTION_FIELD_NUMBER: builtins.int
    CONTINUE_AS_NEW_WORKFLOW_EXECUTION_FIELD_NUMBER: builtins.int
    CANCEL_WORKFLOW_EXECUTION_FIELD_NUMBER: builtins.int
    SET_PATCH_MARKER_FIELD_NUMBER: builtins.int
    START_CHILD_WORKFLOW_EXECUTION_FIELD_NUMBER: builtins.int
    CANCEL_CHILD_WORKFLOW_EXECUTION_FIELD_NUMBER: builtins.int
    REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FIELD_NUMBER: builtins.int
    SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FIELD_NUMBER: builtins.int
    CANCEL_SIGNAL_WORKFLOW_FIELD_NUMBER: builtins.int
    SCHEDULE_LOCAL_ACTIVITY_FIELD_NUMBER: builtins.int
    REQUEST_CANCEL_LOCAL_ACTIVITY_FIELD_NUMBER: builtins.int
    UPSERT_WORKFLOW_SEARCH_ATTRIBUTES_FIELD_NUMBER: builtins.int
    MODIFY_WORKFLOW_PROPERTIES_FIELD_NUMBER: builtins.int
    UPDATE_RESPONSE_FIELD_NUMBER: builtins.int
    SCHEDULE_NEXUS_OPERATION_FIELD_NUMBER: builtins.int
    REQUEST_CANCEL_NEXUS_OPERATION_FIELD_NUMBER: builtins.int
    @property
    def user_metadata(self) -> temporalio.api.sdk.v1.user_metadata_pb2.UserMetadata:
        """User metadata that may or may not be persisted into history depending on the command type.
        Lang layers are expected to expose the setting of the internals of this metadata on a
        per-command basis where applicable.
        """
    @property
    def start_timer(self) -> global___StartTimer: ...
    @property
    def schedule_activity(self) -> global___ScheduleActivity: ...
    @property
    def respond_to_query(self) -> global___QueryResult: ...
    @property
    def request_cancel_activity(self) -> global___RequestCancelActivity: ...
    @property
    def cancel_timer(self) -> global___CancelTimer: ...
    @property
    def complete_workflow_execution(self) -> global___CompleteWorkflowExecution: ...
    @property
    def fail_workflow_execution(self) -> global___FailWorkflowExecution: ...
    @property
    def continue_as_new_workflow_execution(
        self,
    ) -> global___ContinueAsNewWorkflowExecution: ...
    @property
    def cancel_workflow_execution(self) -> global___CancelWorkflowExecution: ...
    @property
    def set_patch_marker(self) -> global___SetPatchMarker: ...
    @property
    def start_child_workflow_execution(
        self,
    ) -> global___StartChildWorkflowExecution: ...
    @property
    def cancel_child_workflow_execution(
        self,
    ) -> global___CancelChildWorkflowExecution: ...
    @property
    def request_cancel_external_workflow_execution(
        self,
    ) -> global___RequestCancelExternalWorkflowExecution: ...
    @property
    def signal_external_workflow_execution(
        self,
    ) -> global___SignalExternalWorkflowExecution: ...
    @property
    def cancel_signal_workflow(self) -> global___CancelSignalWorkflow: ...
    @property
    def schedule_local_activity(self) -> global___ScheduleLocalActivity: ...
    @property
    def request_cancel_local_activity(self) -> global___RequestCancelLocalActivity: ...
    @property
    def upsert_workflow_search_attributes(
        self,
    ) -> global___UpsertWorkflowSearchAttributes: ...
    @property
    def modify_workflow_properties(self) -> global___ModifyWorkflowProperties: ...
    @property
    def update_response(self) -> global___UpdateResponse: ...
    @property
    def schedule_nexus_operation(self) -> global___ScheduleNexusOperation: ...
    @property
    def request_cancel_nexus_operation(
        self,
    ) -> global___RequestCancelNexusOperation: ...
    def __init__(
        self,
        *,
        user_metadata: temporalio.api.sdk.v1.user_metadata_pb2.UserMetadata
        | None = ...,
        start_timer: global___StartTimer | None = ...,
        schedule_activity: global___ScheduleActivity | None = ...,
        respond_to_query: global___QueryResult | None = ...,
        request_cancel_activity: global___RequestCancelActivity | None = ...,
        cancel_timer: global___CancelTimer | None = ...,
        complete_workflow_execution: global___CompleteWorkflowExecution | None = ...,
        fail_workflow_execution: global___FailWorkflowExecution | None = ...,
        continue_as_new_workflow_execution: global___ContinueAsNewWorkflowExecution
        | None = ...,
        cancel_workflow_execution: global___CancelWorkflowExecution | None = ...,
        set_patch_marker: global___SetPatchMarker | None = ...,
        start_child_workflow_execution: global___StartChildWorkflowExecution
        | None = ...,
        cancel_child_workflow_execution: global___CancelChildWorkflowExecution
        | None = ...,
        request_cancel_external_workflow_execution: global___RequestCancelExternalWorkflowExecution
        | None = ...,
        signal_external_workflow_execution: global___SignalExternalWorkflowExecution
        | None = ...,
        cancel_signal_workflow: global___CancelSignalWorkflow | None = ...,
        schedule_local_activity: global___ScheduleLocalActivity | None = ...,
        request_cancel_local_activity: global___RequestCancelLocalActivity | None = ...,
        upsert_workflow_search_attributes: global___UpsertWorkflowSearchAttributes
        | None = ...,
        modify_workflow_properties: global___ModifyWorkflowProperties | None = ...,
        update_response: global___UpdateResponse | None = ...,
        schedule_nexus_operation: global___ScheduleNexusOperation | None = ...,
        request_cancel_nexus_operation: global___RequestCancelNexusOperation
        | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "cancel_child_workflow_execution",
            b"cancel_child_workflow_execution",
            "cancel_signal_workflow",
            b"cancel_signal_workflow",
            "cancel_timer",
            b"cancel_timer",
            "cancel_workflow_execution",
            b"cancel_workflow_execution",
            "complete_workflow_execution",
            b"complete_workflow_execution",
            "continue_as_new_workflow_execution",
            b"continue_as_new_workflow_execution",
            "fail_workflow_execution",
            b"fail_workflow_execution",
            "modify_workflow_properties",
            b"modify_workflow_properties",
            "request_cancel_activity",
            b"request_cancel_activity",
            "request_cancel_external_workflow_execution",
            b"request_cancel_external_workflow_execution",
            "request_cancel_local_activity",
            b"request_cancel_local_activity",
            "request_cancel_nexus_operation",
            b"request_cancel_nexus_operation",
            "respond_to_query",
            b"respond_to_query",
            "schedule_activity",
            b"schedule_activity",
            "schedule_local_activity",
            b"schedule_local_activity",
            "schedule_nexus_operation",
            b"schedule_nexus_operation",
            "set_patch_marker",
            b"set_patch_marker",
            "signal_external_workflow_execution",
            b"signal_external_workflow_execution",
            "start_child_workflow_execution",
            b"start_child_workflow_execution",
            "start_timer",
            b"start_timer",
            "update_response",
            b"update_response",
            "upsert_workflow_search_attributes",
            b"upsert_workflow_search_attributes",
            "user_metadata",
            b"user_metadata",
            "variant",
            b"variant",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "cancel_child_workflow_execution",
            b"cancel_child_workflow_execution",
            "cancel_signal_workflow",
            b"cancel_signal_workflow",
            "cancel_timer",
            b"cancel_timer",
            "cancel_workflow_execution",
            b"cancel_workflow_execution",
            "complete_workflow_execution",
            b"complete_workflow_execution",
            "continue_as_new_workflow_execution",
            b"continue_as_new_workflow_execution",
            "fail_workflow_execution",
            b"fail_workflow_execution",
            "modify_workflow_properties",
            b"modify_workflow_properties",
            "request_cancel_activity",
            b"request_cancel_activity",
            "request_cancel_external_workflow_execution",
            b"request_cancel_external_workflow_execution",
            "request_cancel_local_activity",
            b"request_cancel_local_activity",
            "request_cancel_nexus_operation",
            b"request_cancel_nexus_operation",
            "respond_to_query",
            b"respond_to_query",
            "schedule_activity",
            b"schedule_activity",
            "schedule_local_activity",
            b"schedule_local_activity",
            "schedule_nexus_operation",
            b"schedule_nexus_operation",
            "set_patch_marker",
            b"set_patch_marker",
            "signal_external_workflow_execution",
            b"signal_external_workflow_execution",
            "start_child_workflow_execution",
            b"start_child_workflow_execution",
            "start_timer",
            b"start_timer",
            "update_response",
            b"update_response",
            "upsert_workflow_search_attributes",
            b"upsert_workflow_search_attributes",
            "user_metadata",
            b"user_metadata",
            "variant",
            b"variant",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing_extensions.Literal["variant", b"variant"]
    ) -> (
        typing_extensions.Literal[
            "start_timer",
            "schedule_activity",
            "respond_to_query",
            "request_cancel_activity",
            "cancel_timer",
            "complete_workflow_execution",
            "fail_workflow_execution",
            "continue_as_new_workflow_execution",
            "cancel_workflow_execution",
            "set_patch_marker",
            "start_child_workflow_execution",
            "cancel_child_workflow_execution",
            "request_cancel_external_workflow_execution",
            "signal_external_workflow_execution",
            "cancel_signal_workflow",
            "schedule_local_activity",
            "request_cancel_local_activity",
            "upsert_workflow_search_attributes",
            "modify_workflow_properties",
            "update_response",
            "schedule_nexus_operation",
            "request_cancel_nexus_operation",
        ]
        | None
    ): ...

global___WorkflowCommand = WorkflowCommand

class StartTimer(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SEQ_FIELD_NUMBER: builtins.int
    START_TO_FIRE_TIMEOUT_FIELD_NUMBER: builtins.int
    seq: builtins.int
    """Lang's incremental sequence number, used as the operation identifier"""
    @property
    def start_to_fire_timeout(self) -> google.protobuf.duration_pb2.Duration: ...
    def __init__(
        self,
        *,
        seq: builtins.int = ...,
        start_to_fire_timeout: google.protobuf.duration_pb2.Duration | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "start_to_fire_timeout", b"start_to_fire_timeout"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "seq", b"seq", "start_to_fire_timeout", b"start_to_fire_timeout"
        ],
    ) -> None: ...

global___StartTimer = StartTimer

class CancelTimer(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SEQ_FIELD_NUMBER: builtins.int
    seq: builtins.int
    """Lang's incremental sequence number as passed to `StartTimer`"""
    def __init__(
        self,
        *,
        seq: builtins.int = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing_extensions.Literal["seq", b"seq"]
    ) -> None: ...

global___CancelTimer = CancelTimer

class ScheduleActivity(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class HeadersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> temporalio.api.common.v1.message_pb2.Payload: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: temporalio.api.common.v1.message_pb2.Payload | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing_extensions.Literal["value", b"value"]
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing_extensions.Literal["key", b"key", "value", b"value"],
        ) -> None: ...

    SEQ_FIELD_NUMBER: builtins.int
    ACTIVITY_ID_FIELD_NUMBER: builtins.int
    ACTIVITY_TYPE_FIELD_NUMBER: builtins.int
    TASK_QUEUE_FIELD_NUMBER: builtins.int
    HEADERS_FIELD_NUMBER: builtins.int
    ARGUMENTS_FIELD_NUMBER: builtins.int
    SCHEDULE_TO_CLOSE_TIMEOUT_FIELD_NUMBER: builtins.int
    SCHEDULE_TO_START_TIMEOUT_FIELD_NUMBER: builtins.int
    START_TO_CLOSE_TIMEOUT_FIELD_NUMBER: builtins.int
    HEARTBEAT_TIMEOUT_FIELD_NUMBER: builtins.int
    RETRY_POLICY_FIELD_NUMBER: builtins.int
    CANCELLATION_TYPE_FIELD_NUMBER: builtins.int
    DO_NOT_EAGERLY_EXECUTE_FIELD_NUMBER: builtins.int
    VERSIONING_INTENT_FIELD_NUMBER: builtins.int
    PRIORITY_FIELD_NUMBER: builtins.int
    seq: builtins.int
    """Lang's incremental sequence number, used as the operation identifier"""
    activity_id: builtins.str
    activity_type: builtins.str
    task_queue: builtins.str
    """The name of the task queue to place this activity request in"""
    @property
    def headers(
        self,
    ) -> google.protobuf.internal.containers.MessageMap[
        builtins.str, temporalio.api.common.v1.message_pb2.Payload
    ]: ...
    @property
    def arguments(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        temporalio.api.common.v1.message_pb2.Payload
    ]:
        """Arguments/input to the activity. Called "input" upstream."""
    @property
    def schedule_to_close_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Indicates how long the caller is willing to wait for an activity completion. Limits how long
        retries will be attempted. Either this or start_to_close_timeout_seconds must be specified.
        When not specified defaults to the workflow execution timeout.
        """
    @property
    def schedule_to_start_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Limits time an activity task can stay in a task queue before a worker picks it up. This
        timeout is always non retryable as all a retry would achieve is to put it back into the same
        queue. Defaults to schedule_to_close_timeout or workflow execution timeout if not specified.
        """
    @property
    def start_to_close_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Maximum time an activity is allowed to execute after a pick up by a worker. This timeout is
        always retryable. Either this or schedule_to_close_timeout must be specified.
        """
    @property
    def heartbeat_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Maximum time allowed between successful worker heartbeats."""
    @property
    def retry_policy(self) -> temporalio.api.common.v1.message_pb2.RetryPolicy:
        """Activities are provided by a default retry policy controlled through the service dynamic
        configuration. Retries are happening up to schedule_to_close_timeout. To disable retries set
        retry_policy.maximum_attempts to 1.
        """
    cancellation_type: global___ActivityCancellationType.ValueType
    """Defines how the workflow will wait (or not) for cancellation of the activity to be confirmed"""
    do_not_eagerly_execute: builtins.bool
    """If set, the worker will not tell the service that it can immediately start executing this
    activity. When unset/default, workers will always attempt to do so if activity execution
    slots are available.
    """
    versioning_intent: (
        temporalio.bridge.proto.common.common_pb2.VersioningIntent.ValueType
    )
    """Whether this activity should run on a worker with a compatible build id or not."""
    @property
    def priority(self) -> temporalio.api.common.v1.message_pb2.Priority:
        """The Priority to use for this activity"""
    def __init__(
        self,
        *,
        seq: builtins.int = ...,
        activity_id: builtins.str = ...,
        activity_type: builtins.str = ...,
        task_queue: builtins.str = ...,
        headers: collections.abc.Mapping[
            builtins.str, temporalio.api.common.v1.message_pb2.Payload
        ]
        | None = ...,
        arguments: collections.abc.Iterable[
            temporalio.api.common.v1.message_pb2.Payload
        ]
        | None = ...,
        schedule_to_close_timeout: google.protobuf.duration_pb2.Duration | None = ...,
        schedule_to_start_timeout: google.protobuf.duration_pb2.Duration | None = ...,
        start_to_close_timeout: google.protobuf.duration_pb2.Duration | None = ...,
        heartbeat_timeout: google.protobuf.duration_pb2.Duration | None = ...,
        retry_policy: temporalio.api.common.v1.message_pb2.RetryPolicy | None = ...,
        cancellation_type: global___ActivityCancellationType.ValueType = ...,
        do_not_eagerly_execute: builtins.bool = ...,
        versioning_intent: temporalio.bridge.proto.common.common_pb2.VersioningIntent.ValueType = ...,
        priority: temporalio.api.common.v1.message_pb2.Priority | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "heartbeat_timeout",
            b"heartbeat_timeout",
            "priority",
            b"priority",
            "retry_policy",
            b"retry_policy",
            "schedule_to_close_timeout",
            b"schedule_to_close_timeout",
            "schedule_to_start_timeout",
            b"schedule_to_start_timeout",
            "start_to_close_timeout",
            b"start_to_close_timeout",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "activity_id",
            b"activity_id",
            "activity_type",
            b"activity_type",
            "arguments",
            b"arguments",
            "cancellation_type",
            b"cancellation_type",
            "do_not_eagerly_execute",
            b"do_not_eagerly_execute",
            "headers",
            b"headers",
            "heartbeat_timeout",
            b"heartbeat_timeout",
            "priority",
            b"priority",
            "retry_policy",
            b"retry_policy",
            "schedule_to_close_timeout",
            b"schedule_to_close_timeout",
            "schedule_to_start_timeout",
            b"schedule_to_start_timeout",
            "seq",
            b"seq",
            "start_to_close_timeout",
            b"start_to_close_timeout",
            "task_queue",
            b"task_queue",
            "versioning_intent",
            b"versioning_intent",
        ],
    ) -> None: ...

global___ScheduleActivity = ScheduleActivity

class ScheduleLocalActivity(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class HeadersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> temporalio.api.common.v1.message_pb2.Payload: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: temporalio.api.common.v1.message_pb2.Payload | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing_extensions.Literal["value", b"value"]
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing_extensions.Literal["key", b"key", "value", b"value"],
        ) -> None: ...

    SEQ_FIELD_NUMBER: builtins.int
    ACTIVITY_ID_FIELD_NUMBER: builtins.int
    ACTIVITY_TYPE_FIELD_NUMBER: builtins.int
    ATTEMPT_FIELD_NUMBER: builtins.int
    ORIGINAL_SCHEDULE_TIME_FIELD_NUMBER: builtins.int
    HEADERS_FIELD_NUMBER: builtins.int
    ARGUMENTS_FIELD_NUMBER: builtins.int
    SCHEDULE_TO_CLOSE_TIMEOUT_FIELD_NUMBER: builtins.int
    SCHEDULE_TO_START_TIMEOUT_FIELD_NUMBER: builtins.int
    START_TO_CLOSE_TIMEOUT_FIELD_NUMBER: builtins.int
    RETRY_POLICY_FIELD_NUMBER: builtins.int
    LOCAL_RETRY_THRESHOLD_FIELD_NUMBER: builtins.int
    CANCELLATION_TYPE_FIELD_NUMBER: builtins.int
    seq: builtins.int
    """Lang's incremental sequence number, used as the operation identifier"""
    activity_id: builtins.str
    activity_type: builtins.str
    attempt: builtins.int
    """Local activities can start with a non-1 attempt, if lang has been told to backoff using
    a timer before retrying. It should pass the attempt number from a `DoBackoff` activity
    resolution.
    """
    @property
    def original_schedule_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """If this local activity is a retry (as per the attempt field) this needs to be the original
        scheduling time (as provided in `DoBackoff`)
        """
    @property
    def headers(
        self,
    ) -> google.protobuf.internal.containers.MessageMap[
        builtins.str, temporalio.api.common.v1.message_pb2.Payload
    ]: ...
    @property
    def arguments(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        temporalio.api.common.v1.message_pb2.Payload
    ]:
        """Arguments/input to the activity."""
    @property
    def schedule_to_close_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Indicates how long the caller is willing to wait for local activity completion. Limits how
        long retries will be attempted. When not specified defaults to the workflow execution
        timeout (which may be unset).
        """
    @property
    def schedule_to_start_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Limits time the local activity can idle internally before being executed. That can happen if
        the worker is currently at max concurrent local activity executions. This timeout is always
        non retryable as all a retry would achieve is to put it back into the same queue. Defaults
        to `schedule_to_close_timeout` if not specified and that is set. Must be <=
        `schedule_to_close_timeout` when set, otherwise, it will be clamped down.
        """
    @property
    def start_to_close_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Maximum time the local activity is allowed to execute after the task is dispatched. This
        timeout is always retryable. Either or both of `schedule_to_close_timeout` and this must be
        specified. If set, this must be <= `schedule_to_close_timeout`, otherwise, it will be
        clamped down.
        """
    @property
    def retry_policy(self) -> temporalio.api.common.v1.message_pb2.RetryPolicy:
        """Specify a retry policy for the local activity. By default local activities will be retried
        indefinitely.
        """
    @property
    def local_retry_threshold(self) -> google.protobuf.duration_pb2.Duration:
        """If the activity is retrying and backoff would exceed this value, lang will be told to
        schedule a timer and retry the activity after. Otherwise, backoff will happen internally in
        core. Defaults to 1 minute.
        """
    cancellation_type: global___ActivityCancellationType.ValueType
    """Defines how the workflow will wait (or not) for cancellation of the activity to be
    confirmed. Lang should default this to `WAIT_CANCELLATION_COMPLETED`, even though proto
    will default to `TRY_CANCEL` automatically.
    """
    def __init__(
        self,
        *,
        seq: builtins.int = ...,
        activity_id: builtins.str = ...,
        activity_type: builtins.str = ...,
        attempt: builtins.int = ...,
        original_schedule_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        headers: collections.abc.Mapping[
            builtins.str, temporalio.api.common.v1.message_pb2.Payload
        ]
        | None = ...,
        arguments: collections.abc.Iterable[
            temporalio.api.common.v1.message_pb2.Payload
        ]
        | None = ...,
        schedule_to_close_timeout: google.protobuf.duration_pb2.Duration | None = ...,
        schedule_to_start_timeout: google.protobuf.duration_pb2.Duration | None = ...,
        start_to_close_timeout: google.protobuf.duration_pb2.Duration | None = ...,
        retry_policy: temporalio.api.common.v1.message_pb2.RetryPolicy | None = ...,
        local_retry_threshold: google.protobuf.duration_pb2.Duration | None = ...,
        cancellation_type: global___ActivityCancellationType.ValueType = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "local_retry_threshold",
            b"local_retry_threshold",
            "original_schedule_time",
            b"original_schedule_time",
            "retry_policy",
            b"retry_policy",
            "schedule_to_close_timeout",
            b"schedule_to_close_timeout",
            "schedule_to_start_timeout",
            b"schedule_to_start_timeout",
            "start_to_close_timeout",
            b"start_to_close_timeout",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "activity_id",
            b"activity_id",
            "activity_type",
            b"activity_type",
            "arguments",
            b"arguments",
            "attempt",
            b"attempt",
            "cancellation_type",
            b"cancellation_type",
            "headers",
            b"headers",
            "local_retry_threshold",
            b"local_retry_threshold",
            "original_schedule_time",
            b"original_schedule_time",
            "retry_policy",
            b"retry_policy",
            "schedule_to_close_timeout",
            b"schedule_to_close_timeout",
            "schedule_to_start_timeout",
            b"schedule_to_start_timeout",
            "seq",
            b"seq",
            "start_to_close_timeout",
            b"start_to_close_timeout",
        ],
    ) -> None: ...

global___ScheduleLocalActivity = ScheduleLocalActivity

class RequestCancelActivity(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SEQ_FIELD_NUMBER: builtins.int
    seq: builtins.int
    """Lang's incremental sequence number as passed to `ScheduleActivity`"""
    def __init__(
        self,
        *,
        seq: builtins.int = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing_extensions.Literal["seq", b"seq"]
    ) -> None: ...

global___RequestCancelActivity = RequestCancelActivity

class RequestCancelLocalActivity(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SEQ_FIELD_NUMBER: builtins.int
    seq: builtins.int
    """Lang's incremental sequence number as passed to `ScheduleLocalActivity`"""
    def __init__(
        self,
        *,
        seq: builtins.int = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing_extensions.Literal["seq", b"seq"]
    ) -> None: ...

global___RequestCancelLocalActivity = RequestCancelLocalActivity

class QueryResult(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    QUERY_ID_FIELD_NUMBER: builtins.int
    SUCCEEDED_FIELD_NUMBER: builtins.int
    FAILED_FIELD_NUMBER: builtins.int
    query_id: builtins.str
    """Corresponds to the id provided in the activation job"""
    @property
    def succeeded(self) -> global___QuerySuccess: ...
    @property
    def failed(self) -> temporalio.api.failure.v1.message_pb2.Failure: ...
    def __init__(
        self,
        *,
        query_id: builtins.str = ...,
        succeeded: global___QuerySuccess | None = ...,
        failed: temporalio.api.failure.v1.message_pb2.Failure | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "failed", b"failed", "succeeded", b"succeeded", "variant", b"variant"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "failed",
            b"failed",
            "query_id",
            b"query_id",
            "succeeded",
            b"succeeded",
            "variant",
            b"variant",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing_extensions.Literal["variant", b"variant"]
    ) -> typing_extensions.Literal["succeeded", "failed"] | None: ...

global___QueryResult = QueryResult

class QuerySuccess(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESPONSE_FIELD_NUMBER: builtins.int
    @property
    def response(self) -> temporalio.api.common.v1.message_pb2.Payload: ...
    def __init__(
        self,
        *,
        response: temporalio.api.common.v1.message_pb2.Payload | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing_extensions.Literal["response", b"response"]
    ) -> builtins.bool: ...
    def ClearField(
        self, field_name: typing_extensions.Literal["response", b"response"]
    ) -> None: ...

global___QuerySuccess = QuerySuccess

class CompleteWorkflowExecution(google.protobuf.message.Message):
    """Issued when the workflow completes successfully"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESULT_FIELD_NUMBER: builtins.int
    @property
    def result(self) -> temporalio.api.common.v1.message_pb2.Payload: ...
    def __init__(
        self,
        *,
        result: temporalio.api.common.v1.message_pb2.Payload | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing_extensions.Literal["result", b"result"]
    ) -> builtins.bool: ...
    def ClearField(
        self, field_name: typing_extensions.Literal["result", b"result"]
    ) -> None: ...

global___CompleteWorkflowExecution = CompleteWorkflowExecution

class FailWorkflowExecution(google.protobuf.message.Message):
    """Issued when the workflow errors out"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FAILURE_FIELD_NUMBER: builtins.int
    @property
    def failure(self) -> temporalio.api.failure.v1.message_pb2.Failure: ...
    def __init__(
        self,
        *,
        failure: temporalio.api.failure.v1.message_pb2.Failure | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing_extensions.Literal["failure", b"failure"]
    ) -> builtins.bool: ...
    def ClearField(
        self, field_name: typing_extensions.Literal["failure", b"failure"]
    ) -> None: ...

global___FailWorkflowExecution = FailWorkflowExecution

class ContinueAsNewWorkflowExecution(google.protobuf.message.Message):
    """Continue the workflow as a new execution"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class MemoEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> temporalio.api.common.v1.message_pb2.Payload: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: temporalio.api.common.v1.message_pb2.Payload | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing_extensions.Literal["value", b"value"]
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing_extensions.Literal["key", b"key", "value", b"value"],
        ) -> None: ...

    class HeadersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> temporalio.api.common.v1.message_pb2.Payload: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: temporalio.api.common.v1.message_pb2.Payload | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing_extensions.Literal["value", b"value"]
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing_extensions.Literal["key", b"key", "value", b"value"],
        ) -> None: ...

    class SearchAttributesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> temporalio.api.common.v1.message_pb2.Payload: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: temporalio.api.common.v1.message_pb2.Payload | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing_extensions.Literal["value", b"value"]
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing_extensions.Literal["key", b"key", "value", b"value"],
        ) -> None: ...

    WORKFLOW_TYPE_FIELD_NUMBER: builtins.int
    TASK_QUEUE_FIELD_NUMBER: builtins.int
    ARGUMENTS_FIELD_NUMBER: builtins.int
    WORKFLOW_RUN_TIMEOUT_FIELD_NUMBER: builtins.int
    WORKFLOW_TASK_TIMEOUT_FIELD_NUMBER: builtins.int
    MEMO_FIELD_NUMBER: builtins.int
    HEADERS_FIELD_NUMBER: builtins.int
    SEARCH_ATTRIBUTES_FIELD_NUMBER: builtins.int
    RETRY_POLICY_FIELD_NUMBER: builtins.int
    VERSIONING_INTENT_FIELD_NUMBER: builtins.int
    workflow_type: builtins.str
    """The identifier the lang-specific sdk uses to execute workflow code"""
    task_queue: builtins.str
    """Task queue for the new workflow execution"""
    @property
    def arguments(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        temporalio.api.common.v1.message_pb2.Payload
    ]:
        """Inputs to the workflow code. Should be specified. Will not re-use old arguments, as that
        typically wouldn't make any sense.
        """
    @property
    def workflow_run_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Timeout for a single run of the new workflow. Will not re-use current workflow's value."""
    @property
    def workflow_task_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Timeout of a single workflow task. Will not re-use current workflow's value."""
    @property
    def memo(
        self,
    ) -> google.protobuf.internal.containers.MessageMap[
        builtins.str, temporalio.api.common.v1.message_pb2.Payload
    ]:
        """If set, the new workflow will have this memo. If unset, re-uses the current workflow's memo"""
    @property
    def headers(
        self,
    ) -> google.protobuf.internal.containers.MessageMap[
        builtins.str, temporalio.api.common.v1.message_pb2.Payload
    ]:
        """If set, the new workflow will have these headers. Will *not* re-use current workflow's
        headers otherwise.
        """
    @property
    def search_attributes(
        self,
    ) -> google.protobuf.internal.containers.MessageMap[
        builtins.str, temporalio.api.common.v1.message_pb2.Payload
    ]:
        """If set, the new workflow will have these search attributes. If unset, re-uses the current
        workflow's search attributes.
        """
    @property
    def retry_policy(self) -> temporalio.api.common.v1.message_pb2.RetryPolicy:
        """If set, the new workflow will have this retry policy. If unset, re-uses the current
        workflow's retry policy.
        """
    versioning_intent: (
        temporalio.bridge.proto.common.common_pb2.VersioningIntent.ValueType
    )
    """Whether the continued workflow should run on a worker with a compatible build id or not."""
    def __init__(
        self,
        *,
        workflow_type: builtins.str = ...,
        task_queue: builtins.str = ...,
        arguments: collections.abc.Iterable[
            temporalio.api.common.v1.message_pb2.Payload
        ]
        | None = ...,
        workflow_run_timeout: google.protobuf.duration_pb2.Duration | None = ...,
        workflow_task_timeout: google.protobuf.duration_pb2.Duration | None = ...,
        memo: collections.abc.Mapping[
            builtins.str, temporalio.api.common.v1.message_pb2.Payload
        ]
        | None = ...,
        headers: collections.abc.Mapping[
            builtins.str, temporalio.api.common.v1.message_pb2.Payload
        ]
        | None = ...,
        search_attributes: collections.abc.Mapping[
            builtins.str, temporalio.api.common.v1.message_pb2.Payload
        ]
        | None = ...,
        retry_policy: temporalio.api.common.v1.message_pb2.RetryPolicy | None = ...,
        versioning_intent: temporalio.bridge.proto.common.common_pb2.VersioningIntent.ValueType = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "retry_policy",
            b"retry_policy",
            "workflow_run_timeout",
            b"workflow_run_timeout",
            "workflow_task_timeout",
            b"workflow_task_timeout",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "arguments",
            b"arguments",
            "headers",
            b"headers",
            "memo",
            b"memo",
            "retry_policy",
            b"retry_policy",
            "search_attributes",
            b"search_attributes",
            "task_queue",
            b"task_queue",
            "versioning_intent",
            b"versioning_intent",
            "workflow_run_timeout",
            b"workflow_run_timeout",
            "workflow_task_timeout",
            b"workflow_task_timeout",
            "workflow_type",
            b"workflow_type",
        ],
    ) -> None: ...

global___ContinueAsNewWorkflowExecution = ContinueAsNewWorkflowExecution

class CancelWorkflowExecution(google.protobuf.message.Message):
    """Indicate a workflow has completed as cancelled. Generally sent as a response to an activation
    containing a cancellation job.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___CancelWorkflowExecution = CancelWorkflowExecution

class SetPatchMarker(google.protobuf.message.Message):
    """A request to set/check if a certain patch is present or not"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PATCH_ID_FIELD_NUMBER: builtins.int
    DEPRECATED_FIELD_NUMBER: builtins.int
    patch_id: builtins.str
    """A user-chosen identifier for this patch. If the same identifier is used in multiple places in
    the code, those places are considered to be versioned as one unit. IE: The check call will
    return the same result for all of them
    """
    deprecated: builtins.bool
    """Can be set to true to indicate that branches using this change are being removed, and all
    future worker deployments will only have the "with change" code in them.
    """
    def __init__(
        self,
        *,
        patch_id: builtins.str = ...,
        deprecated: builtins.bool = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "deprecated", b"deprecated", "patch_id", b"patch_id"
        ],
    ) -> None: ...

global___SetPatchMarker = SetPatchMarker

class StartChildWorkflowExecution(google.protobuf.message.Message):
    """Start a child workflow execution"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class HeadersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> temporalio.api.common.v1.message_pb2.Payload: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: temporalio.api.common.v1.message_pb2.Payload | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing_extensions.Literal["value", b"value"]
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing_extensions.Literal["key", b"key", "value", b"value"],
        ) -> None: ...

    class MemoEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> temporalio.api.common.v1.message_pb2.Payload: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: temporalio.api.common.v1.message_pb2.Payload | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing_extensions.Literal["value", b"value"]
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing_extensions.Literal["key", b"key", "value", b"value"],
        ) -> None: ...

    class SearchAttributesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> temporalio.api.common.v1.message_pb2.Payload: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: temporalio.api.common.v1.message_pb2.Payload | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing_extensions.Literal["value", b"value"]
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing_extensions.Literal["key", b"key", "value", b"value"],
        ) -> None: ...

    SEQ_FIELD_NUMBER: builtins.int
    NAMESPACE_FIELD_NUMBER: builtins.int
    WORKFLOW_ID_FIELD_NUMBER: builtins.int
    WORKFLOW_TYPE_FIELD_NUMBER: builtins.int
    TASK_QUEUE_FIELD_NUMBER: builtins.int
    INPUT_FIELD_NUMBER: builtins.int
    WORKFLOW_EXECUTION_TIMEOUT_FIELD_NUMBER: builtins.int
    WORKFLOW_RUN_TIMEOUT_FIELD_NUMBER: builtins.int
    WORKFLOW_TASK_TIMEOUT_FIELD_NUMBER: builtins.int
    PARENT_CLOSE_POLICY_FIELD_NUMBER: builtins.int
    WORKFLOW_ID_REUSE_POLICY_FIELD_NUMBER: builtins.int
    RETRY_POLICY_FIELD_NUMBER: builtins.int
    CRON_SCHEDULE_FIELD_NUMBER: builtins.int
    HEADERS_FIELD_NUMBER: builtins.int
    MEMO_FIELD_NUMBER: builtins.int
    SEARCH_ATTRIBUTES_FIELD_NUMBER: builtins.int
    CANCELLATION_TYPE_FIELD_NUMBER: builtins.int
    VERSIONING_INTENT_FIELD_NUMBER: builtins.int
    PRIORITY_FIELD_NUMBER: builtins.int
    seq: builtins.int
    """Lang's incremental sequence number, used as the operation identifier"""
    namespace: builtins.str
    workflow_id: builtins.str
    workflow_type: builtins.str
    task_queue: builtins.str
    @property
    def input(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        temporalio.api.common.v1.message_pb2.Payload
    ]: ...
    @property
    def workflow_execution_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Total workflow execution timeout including retries and continue as new."""
    @property
    def workflow_run_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Timeout of a single workflow run."""
    @property
    def workflow_task_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Timeout of a single workflow task."""
    parent_close_policy: temporalio.bridge.proto.child_workflow.child_workflow_pb2.ParentClosePolicy.ValueType
    """Default: PARENT_CLOSE_POLICY_TERMINATE."""
    workflow_id_reuse_policy: (
        temporalio.api.enums.v1.workflow_pb2.WorkflowIdReusePolicy.ValueType
    )
    """string control = 11; (unused from StartChildWorkflowExecutionCommandAttributes)
    Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
    """
    @property
    def retry_policy(self) -> temporalio.api.common.v1.message_pb2.RetryPolicy: ...
    cron_schedule: builtins.str
    @property
    def headers(
        self,
    ) -> google.protobuf.internal.containers.MessageMap[
        builtins.str, temporalio.api.common.v1.message_pb2.Payload
    ]:
        """Header fields"""
    @property
    def memo(
        self,
    ) -> google.protobuf.internal.containers.MessageMap[
        builtins.str, temporalio.api.common.v1.message_pb2.Payload
    ]:
        """Memo fields"""
    @property
    def search_attributes(
        self,
    ) -> google.protobuf.internal.containers.MessageMap[
        builtins.str, temporalio.api.common.v1.message_pb2.Payload
    ]:
        """Search attributes"""
    cancellation_type: temporalio.bridge.proto.child_workflow.child_workflow_pb2.ChildWorkflowCancellationType.ValueType
    """Defines behaviour of the underlying workflow when child workflow cancellation has been requested."""
    versioning_intent: (
        temporalio.bridge.proto.common.common_pb2.VersioningIntent.ValueType
    )
    """Whether this child should run on a worker with a compatible build id or not."""
    @property
    def priority(self) -> temporalio.api.common.v1.message_pb2.Priority:
        """The Priority to use for this activity"""
    def __init__(
        self,
        *,
        seq: builtins.int = ...,
        namespace: builtins.str = ...,
        workflow_id: builtins.str = ...,
        workflow_type: builtins.str = ...,
        task_queue: builtins.str = ...,
        input: collections.abc.Iterable[temporalio.api.common.v1.message_pb2.Payload]
        | None = ...,
        workflow_execution_timeout: google.protobuf.duration_pb2.Duration | None = ...,
        workflow_run_timeout: google.protobuf.duration_pb2.Duration | None = ...,
        workflow_task_timeout: google.protobuf.duration_pb2.Duration | None = ...,
        parent_close_policy: temporalio.bridge.proto.child_workflow.child_workflow_pb2.ParentClosePolicy.ValueType = ...,
        workflow_id_reuse_policy: temporalio.api.enums.v1.workflow_pb2.WorkflowIdReusePolicy.ValueType = ...,
        retry_policy: temporalio.api.common.v1.message_pb2.RetryPolicy | None = ...,
        cron_schedule: builtins.str = ...,
        headers: collections.abc.Mapping[
            builtins.str, temporalio.api.common.v1.message_pb2.Payload
        ]
        | None = ...,
        memo: collections.abc.Mapping[
            builtins.str, temporalio.api.common.v1.message_pb2.Payload
        ]
        | None = ...,
        search_attributes: collections.abc.Mapping[
            builtins.str, temporalio.api.common.v1.message_pb2.Payload
        ]
        | None = ...,
        cancellation_type: temporalio.bridge.proto.child_workflow.child_workflow_pb2.ChildWorkflowCancellationType.ValueType = ...,
        versioning_intent: temporalio.bridge.proto.common.common_pb2.VersioningIntent.ValueType = ...,
        priority: temporalio.api.common.v1.message_pb2.Priority | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "priority",
            b"priority",
            "retry_policy",
            b"retry_policy",
            "workflow_execution_timeout",
            b"workflow_execution_timeout",
            "workflow_run_timeout",
            b"workflow_run_timeout",
            "workflow_task_timeout",
            b"workflow_task_timeout",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "cancellation_type",
            b"cancellation_type",
            "cron_schedule",
            b"cron_schedule",
            "headers",
            b"headers",
            "input",
            b"input",
            "memo",
            b"memo",
            "namespace",
            b"namespace",
            "parent_close_policy",
            b"parent_close_policy",
            "priority",
            b"priority",
            "retry_policy",
            b"retry_policy",
            "search_attributes",
            b"search_attributes",
            "seq",
            b"seq",
            "task_queue",
            b"task_queue",
            "versioning_intent",
            b"versioning_intent",
            "workflow_execution_timeout",
            b"workflow_execution_timeout",
            "workflow_id",
            b"workflow_id",
            "workflow_id_reuse_policy",
            b"workflow_id_reuse_policy",
            "workflow_run_timeout",
            b"workflow_run_timeout",
            "workflow_task_timeout",
            b"workflow_task_timeout",
            "workflow_type",
            b"workflow_type",
        ],
    ) -> None: ...

global___StartChildWorkflowExecution = StartChildWorkflowExecution

class CancelChildWorkflowExecution(google.protobuf.message.Message):
    """Cancel a child workflow"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CHILD_WORKFLOW_SEQ_FIELD_NUMBER: builtins.int
    REASON_FIELD_NUMBER: builtins.int
    child_workflow_seq: builtins.int
    """Sequence number as given to the `StartChildWorkflowExecution` command"""
    reason: builtins.str
    """A reason for the cancellation"""
    def __init__(
        self,
        *,
        child_workflow_seq: builtins.int = ...,
        reason: builtins.str = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "child_workflow_seq", b"child_workflow_seq", "reason", b"reason"
        ],
    ) -> None: ...

global___CancelChildWorkflowExecution = CancelChildWorkflowExecution

class RequestCancelExternalWorkflowExecution(google.protobuf.message.Message):
    """Request cancellation of an external workflow execution. For cancellation of a child workflow,
    prefer `CancelChildWorkflowExecution` instead, as it guards against cancel-before-start issues.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SEQ_FIELD_NUMBER: builtins.int
    WORKFLOW_EXECUTION_FIELD_NUMBER: builtins.int
    REASON_FIELD_NUMBER: builtins.int
    seq: builtins.int
    """Lang's incremental sequence number, used as the operation identifier"""
    @property
    def workflow_execution(
        self,
    ) -> temporalio.bridge.proto.common.common_pb2.NamespacedWorkflowExecution:
        """The workflow instance being targeted"""
    reason: builtins.str
    """A reason for the cancellation"""
    def __init__(
        self,
        *,
        seq: builtins.int = ...,
        workflow_execution: temporalio.bridge.proto.common.common_pb2.NamespacedWorkflowExecution
        | None = ...,
        reason: builtins.str = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "workflow_execution", b"workflow_execution"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "reason",
            b"reason",
            "seq",
            b"seq",
            "workflow_execution",
            b"workflow_execution",
        ],
    ) -> None: ...

global___RequestCancelExternalWorkflowExecution = RequestCancelExternalWorkflowExecution

class SignalExternalWorkflowExecution(google.protobuf.message.Message):
    """Send a signal to an external or child workflow"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class HeadersEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> temporalio.api.common.v1.message_pb2.Payload: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: temporalio.api.common.v1.message_pb2.Payload | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing_extensions.Literal["value", b"value"]
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing_extensions.Literal["key", b"key", "value", b"value"],
        ) -> None: ...

    SEQ_FIELD_NUMBER: builtins.int
    WORKFLOW_EXECUTION_FIELD_NUMBER: builtins.int
    CHILD_WORKFLOW_ID_FIELD_NUMBER: builtins.int
    SIGNAL_NAME_FIELD_NUMBER: builtins.int
    ARGS_FIELD_NUMBER: builtins.int
    HEADERS_FIELD_NUMBER: builtins.int
    seq: builtins.int
    """Lang's incremental sequence number, used as the operation identifier"""
    @property
    def workflow_execution(
        self,
    ) -> temporalio.bridge.proto.common.common_pb2.NamespacedWorkflowExecution:
        """A specific workflow instance"""
    child_workflow_id: builtins.str
    """The desired target must be a child of the issuing workflow, and this is its workflow id"""
    signal_name: builtins.str
    """Name of the signal handler"""
    @property
    def args(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        temporalio.api.common.v1.message_pb2.Payload
    ]:
        """Arguments for the handler"""
    @property
    def headers(
        self,
    ) -> google.protobuf.internal.containers.MessageMap[
        builtins.str, temporalio.api.common.v1.message_pb2.Payload
    ]:
        """Headers to attach to the signal"""
    def __init__(
        self,
        *,
        seq: builtins.int = ...,
        workflow_execution: temporalio.bridge.proto.common.common_pb2.NamespacedWorkflowExecution
        | None = ...,
        child_workflow_id: builtins.str = ...,
        signal_name: builtins.str = ...,
        args: collections.abc.Iterable[temporalio.api.common.v1.message_pb2.Payload]
        | None = ...,
        headers: collections.abc.Mapping[
            builtins.str, temporalio.api.common.v1.message_pb2.Payload
        ]
        | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "child_workflow_id",
            b"child_workflow_id",
            "target",
            b"target",
            "workflow_execution",
            b"workflow_execution",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "args",
            b"args",
            "child_workflow_id",
            b"child_workflow_id",
            "headers",
            b"headers",
            "seq",
            b"seq",
            "signal_name",
            b"signal_name",
            "target",
            b"target",
            "workflow_execution",
            b"workflow_execution",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing_extensions.Literal["target", b"target"]
    ) -> (
        typing_extensions.Literal["workflow_execution", "child_workflow_id"] | None
    ): ...

global___SignalExternalWorkflowExecution = SignalExternalWorkflowExecution

class CancelSignalWorkflow(google.protobuf.message.Message):
    """Can be used to cancel not-already-sent `SignalExternalWorkflowExecution` commands"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SEQ_FIELD_NUMBER: builtins.int
    seq: builtins.int
    """Lang's incremental sequence number as passed to `SignalExternalWorkflowExecution`"""
    def __init__(
        self,
        *,
        seq: builtins.int = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing_extensions.Literal["seq", b"seq"]
    ) -> None: ...

global___CancelSignalWorkflow = CancelSignalWorkflow

class UpsertWorkflowSearchAttributes(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class SearchAttributesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> temporalio.api.common.v1.message_pb2.Payload: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: temporalio.api.common.v1.message_pb2.Payload | None = ...,
        ) -> None: ...
        def HasField(
            self, field_name: typing_extensions.Literal["value", b"value"]
        ) -> builtins.bool: ...
        def ClearField(
            self,
            field_name: typing_extensions.Literal["key", b"key", "value", b"value"],
        ) -> None: ...

    SEARCH_ATTRIBUTES_FIELD_NUMBER: builtins.int
    @property
    def search_attributes(
        self,
    ) -> google.protobuf.internal.containers.MessageMap[
        builtins.str, temporalio.api.common.v1.message_pb2.Payload
    ]:
        """SearchAttributes fields - equivalent to indexed_fields on api. Key = search index, Value =
        value?
        """
    def __init__(
        self,
        *,
        search_attributes: collections.abc.Mapping[
            builtins.str, temporalio.api.common.v1.message_pb2.Payload
        ]
        | None = ...,
    ) -> None: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "search_attributes", b"search_attributes"
        ],
    ) -> None: ...

global___UpsertWorkflowSearchAttributes = UpsertWorkflowSearchAttributes

class ModifyWorkflowProperties(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    UPSERTED_MEMO_FIELD_NUMBER: builtins.int
    @property
    def upserted_memo(self) -> temporalio.api.common.v1.message_pb2.Memo:
        """If set, update the workflow memo with the provided values. The values will be merged with
        the existing memo. If the user wants to delete values, a default/empty Payload should be
        used as the value for the key being deleted.
        """
    def __init__(
        self,
        *,
        upserted_memo: temporalio.api.common.v1.message_pb2.Memo | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing_extensions.Literal["upserted_memo", b"upserted_memo"]
    ) -> builtins.bool: ...
    def ClearField(
        self, field_name: typing_extensions.Literal["upserted_memo", b"upserted_memo"]
    ) -> None: ...

global___ModifyWorkflowProperties = ModifyWorkflowProperties

class UpdateResponse(google.protobuf.message.Message):
    """A reply to a `DoUpdate` job - lang must run the update's validator if told to, and then
    immediately run the handler, if the update was accepted.

    There must always be an accepted or rejected response immediately, in the same activation as
    this job, to indicate the result of the validator. Accepted for ran and accepted or skipped, or
    rejected for rejected.

    Then, in the same or any subsequent activation, after the update handler has completed, respond
    with completed or rejected as appropriate for the result of the handler.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PROTOCOL_INSTANCE_ID_FIELD_NUMBER: builtins.int
    ACCEPTED_FIELD_NUMBER: builtins.int
    REJECTED_FIELD_NUMBER: builtins.int
    COMPLETED_FIELD_NUMBER: builtins.int
    protocol_instance_id: builtins.str
    """The protocol message instance ID"""
    @property
    def accepted(self) -> google.protobuf.empty_pb2.Empty:
        """Must be sent if the update's validator has passed (or lang was not asked to run it, and
        thus should be considered already-accepted, allowing lang to always send the same
        sequence on replay).
        """
    @property
    def rejected(self) -> temporalio.api.failure.v1.message_pb2.Failure:
        """Must be sent if the update's validator does not pass, or after acceptance if the update
        handler fails.
        """
    @property
    def completed(self) -> temporalio.api.common.v1.message_pb2.Payload:
        """Must be sent once the update handler completes successfully."""
    def __init__(
        self,
        *,
        protocol_instance_id: builtins.str = ...,
        accepted: google.protobuf.empty_pb2.Empty | None = ...,
        rejected: temporalio.api.failure.v1.message_pb2.Failure | None = ...,
        completed: temporalio.api.common.v1.message_pb2.Payload | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "accepted",
            b"accepted",
            "completed",
            b"completed",
            "rejected",
            b"rejected",
            "response",
            b"response",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "accepted",
            b"accepted",
            "completed",
            b"completed",
            "protocol_instance_id",
            b"protocol_instance_id",
            "rejected",
            b"rejected",
            "response",
            b"response",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing_extensions.Literal["response", b"response"]
    ) -> typing_extensions.Literal["accepted", "rejected", "completed"] | None: ...

global___UpdateResponse = UpdateResponse

class ScheduleNexusOperation(google.protobuf.message.Message):
    """A request to begin a Nexus operation"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class NexusHeaderEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        value: builtins.str
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: builtins.str = ...,
        ) -> None: ...
        def ClearField(
            self,
            field_name: typing_extensions.Literal["key", b"key", "value", b"value"],
        ) -> None: ...

    SEQ_FIELD_NUMBER: builtins.int
    ENDPOINT_FIELD_NUMBER: builtins.int
    SERVICE_FIELD_NUMBER: builtins.int
    OPERATION_FIELD_NUMBER: builtins.int
    INPUT_FIELD_NUMBER: builtins.int
    SCHEDULE_TO_CLOSE_TIMEOUT_FIELD_NUMBER: builtins.int
    NEXUS_HEADER_FIELD_NUMBER: builtins.int
    CANCELLATION_TYPE_FIELD_NUMBER: builtins.int
    seq: builtins.int
    """Lang's incremental sequence number, used as the operation identifier"""
    endpoint: builtins.str
    """Endpoint name, must exist in the endpoint registry or this command will fail."""
    service: builtins.str
    """Service name."""
    operation: builtins.str
    """Operation name."""
    @property
    def input(self) -> temporalio.api.common.v1.message_pb2.Payload:
        """Input for the operation. The server converts this into Nexus request content and the
        appropriate content headers internally when sending the StartOperation request. On the
        handler side, if it is also backed by Temporal, the content is transformed back to the
        original Payload sent in this command.
        """
    @property
    def schedule_to_close_timeout(self) -> google.protobuf.duration_pb2.Duration:
        """Schedule-to-close timeout for this operation.
        Indicates how long the caller is willing to wait for operation completion.
        Calls are retried internally by the server.
        """
    @property
    def nexus_header(
        self,
    ) -> google.protobuf.internal.containers.ScalarMap[builtins.str, builtins.str]:
        """Header to attach to the Nexus request.
        Users are responsible for encrypting sensitive data in this header as it is stored in
        workflow history and transmitted to external services as-is. This is useful for propagating
        tracing information. Note these headers are not the same as Temporal headers on internal
        activities and child workflows, these are transmitted to Nexus operations that may be
        external and are not traditional payloads.
        """
    cancellation_type: (
        temporalio.bridge.proto.nexus.nexus_pb2.NexusOperationCancellationType.ValueType
    )
    """Defines behaviour of the underlying nexus operation when operation cancellation has been requested."""
    def __init__(
        self,
        *,
        seq: builtins.int = ...,
        endpoint: builtins.str = ...,
        service: builtins.str = ...,
        operation: builtins.str = ...,
        input: temporalio.api.common.v1.message_pb2.Payload | None = ...,
        schedule_to_close_timeout: google.protobuf.duration_pb2.Duration | None = ...,
        nexus_header: collections.abc.Mapping[builtins.str, builtins.str] | None = ...,
        cancellation_type: temporalio.bridge.proto.nexus.nexus_pb2.NexusOperationCancellationType.ValueType = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing_extensions.Literal[
            "input", b"input", "schedule_to_close_timeout", b"schedule_to_close_timeout"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing_extensions.Literal[
            "cancellation_type",
            b"cancellation_type",
            "endpoint",
            b"endpoint",
            "input",
            b"input",
            "nexus_header",
            b"nexus_header",
            "operation",
            b"operation",
            "schedule_to_close_timeout",
            b"schedule_to_close_timeout",
            "seq",
            b"seq",
            "service",
            b"service",
        ],
    ) -> None: ...

global___ScheduleNexusOperation = ScheduleNexusOperation

class RequestCancelNexusOperation(google.protobuf.message.Message):
    """Request cancellation of a nexus operation started via `ScheduleNexusOperation`"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SEQ_FIELD_NUMBER: builtins.int
    seq: builtins.int
    """Lang's incremental sequence number as passed to `ScheduleNexusOperation`"""
    def __init__(
        self,
        *,
        seq: builtins.int = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing_extensions.Literal["seq", b"seq"]
    ) -> None: ...

global___RequestCancelNexusOperation = RequestCancelNexusOperation
